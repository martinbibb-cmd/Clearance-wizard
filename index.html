<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie: Final</title>
    
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" onload="App.onCvLoaded()" onerror="App.onCvError()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root { --wb-blue: #005eb8; --wb-red: #e30613; }
        body { margin: 0; background: #000; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; }
        
        #camera-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #ar-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; display: flex; flex-direction: column; pointer-events: none; }
        
        .interactive { pointer-events: auto; }
        .card { background: rgba(255,255,255,0.95); padding: 20px; border-radius: 12px; margin: 20px auto; width: 90%; max-width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .hidden { display: none !important; }
        
        /* ArUco Marker Generator Styles */
        #ar-generator-panel { margin-top: 10px; }
        #marker-print-area { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; justify-items: center; padding: 10px; border: 1px dashed #ccc; background: #f9f9f9; }
        .marker-container { width: 43mm; height: 43mm; display: flex; align-items: center; justify-content: center; }
        .marker-container canvas { width: 100%; height: 100%; object-fit: contain; }
        @media print {
            body * { visibility: hidden; }
            #marker-print-area, #marker-print-area * { visibility: visible; }
            #marker-print-area { position: absolute; left: 0; top: 0; margin: 0; padding: 0; border: none; background: white; width: 210mm; }
            .marker-container { width: 43mm; height: 43mm; margin: 5mm; }
        }
        
        h1 { margin: 0 0 15px 0; font-size: 1.2rem; color: #333; text-align: center; }
        label { display: block; font-size: 0.8rem; color: #666; margin-bottom: 5px; font-weight: 700; text-transform: uppercase; }
        select, button, input[type="number"] { width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #ccc; margin-bottom: 15px; font-size: 1rem; background: white; }
        
        button.primary { background: var(--wb-blue); color: white; border: none; font-weight: 600; cursor: pointer; }
        button.primary:disabled { background: #999; cursor: not-allowed; opacity: 0.7; } /* Disabled button styling */
        
        #status-pill { 
            align-self: center; margin-top: 50px; padding: 10px 25px; border-radius: 30px; 
            font-size: 0.9rem; font-weight: 600; background: rgba(255,255,255,0.9); color: #333;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
        }
        #status-pill.locked { background: var(--wb-red); color: white; }

        .control-bar { margin-top: auto; padding: 20px; display: flex; gap: 15px; justify-content: center; background: linear-gradient(to top, rgba(0,0,0,0.5), transparent); }
        .btn-round { width: 60px; height: 60px; border-radius: 50%; border: none; font-size: 1.5rem; background: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer; }
        
        #touch-pad { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; touch-action: none; }
    </style>
</head>
<body>

    <video id="camera-layer" autoplay playsinline muted></video>
    <canvas id="ar-layer"></canvas>
    <div id="touch-pad"></div>

    <div id="ui-layer">
        <div id="status-pill" class="hidden">Initializing...</div>

        <div id="menu-panel" class="card interactive">
            <h1>üî• Clearance Genie</h1>
            
            <label>1. Marker Size</label>
            <select id="input-size" onchange="App.onSizeChange()">
                <option value="45">45mm (Your Marker)</option>
                <option value="53">53mm (Credit Card)</option>
                <option value="160">160mm (A4 Print)</option>
                <option value="190">190mm (A4 Square)</option>
                <option value="custom">Custom Size...</option>
            </select>
            
            <div id="custom-size-container" class="hidden">
                <label>Custom Marker Size (mm)</label>
                <input type="number" id="custom-size-input" min="10" max="500" step="1" placeholder="Enter size in mm" aria-label="Custom marker size in millimeters">
            </div>

            <label>2. Category</label>
            <select id="input-category" onchange="App.updateModels()">
                <option value="boiler">üî• Boilers</option>
                <option value="flue">‚≠ï Flues</option>
                <option value="radiator">‚ô®Ô∏è Radiators</option>
                <option value="cylinder">üõ¢Ô∏è Cylinders</option>
            </select>

            <label>3. Select Model</label>
            <select id="input-type" onchange="App.onModelChange()">
            </select>

            <div id="custom-radiator-container" class="hidden">
                <label>Radiator Width (mm)</label>
                <input type="number" id="custom-radiator-width" min="100" max="3000" step="1" value="1000" placeholder="Enter width in mm" aria-label="Custom radiator width in millimeters">
                
                <label>Radiator Height (mm)</label>
                <input type="number" id="custom-radiator-height" min="100" max="2000" step="1" value="600" placeholder="Enter height in mm" aria-label="Custom radiator height in millimeters">
            </div>

            <button id="start-camera-btn" class="primary" onclick="App.startSession()" disabled>Loading OpenCV...</button>
        </div>

        <div id="ar-generator-panel" class="card interactive">
            <h1>üìÑ arUco Marker Generator</h1>
            <p style="font-size:0.9rem; color:#666;">Print credit-card sized markers (43mm) to use for clearance checks.</p>
            <button id="generate-markers-btn" class="primary" onclick="App.generateArUcoMarkers()" disabled>Loading OpenCV...</button>
            <div id="marker-print-area" class="hidden"></div>
        </div>

        <div id="controls-panel" class="control-bar interactive hidden">
            <button class="btn-round" onclick="App.resetObject()">‚Ü∫</button>
            <button class="btn-round" style="background: var(--wb-blue); color: white;" onclick="App.lockView()">üîí</button>
        </div>

        <div id="result-panel" class="control-bar interactive hidden">
            <button class="btn-round" style="background: var(--wb-blue); color: white;" onclick="App.captureImage()" aria-label="Capture AR view" title="Capture current AR view as image">üì∑</button>
            <button class="primary" style="max-width:200px;" onclick="location.reload()">New Check</button>
        </div>
    </div>

<script>
// ==========================================
// üîß OPENCV LOADING STRATEGY
// ==========================================
// OpenCV.js is loaded asynchronously from CDN in the <head> section.
//
// Loading process:
// 1. Browser downloads opencv.js (~8MB) from https://docs.opencv.org/4.5.2/opencv.js
// 2. onload fires -> App.onCvLoaded() starts polling for cv.aruco
// 3. Internal OpenCV initialization completes (cv.aruco becomes available)
// 4. Buttons are enabled and app is ready
//
// Troubleshooting stuck on "Loading OpenCV...":
// - Open browser console (F12) to see diagnostic messages
// - Check Network tab to see if opencv.js downloaded successfully
// - Look for error messages about blocked scripts or CORS issues
// - If CDN is blocked, download opencv.js and host it locally (see onCvError logs)
//
// Mobile considerations:
// - Large file size (8MB) may take longer on mobile networks
// - Some mobile browsers may restrict external script loading
// - Consider hosting locally for production deployment
// ==========================================

// ==========================================
// üìö DATA: APPLIANCE DATABASE
// ==========================================
const APPLIANCE_DB = [
    // --- FLUES ---
    { id: "flue", category: "flue", label: "Standard Round Terminal", type: "flue", radius: 50, clearance: 300 },

    // --- BOILERS ---
    { id: "wb_4000", category: "boiler", label: "Worcester 4000 (Combi/System)", w: 400, h: 724, d: 310, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 600 } },
    { id: "wb_8000", category: "boiler", label: "Worcester 8000 (CDi/Si Compact)", w: 440, h: 780, d: 365, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 450 } },
    { id: "wb_ri",   category: "boiler", label: "Worcester Ri Compact", w: 390, h: 600, d: 270, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 600 } },
    { id: "wb_cdi",  category: "boiler", label: "Worcester CDi Compact", w: 390, h: 690, d: 310, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 450 } },
    { id: "ideal_logic", category: "boiler", label: "Ideal Logic+ / Max", w: 395, h: 700, d: 310, clearance: { top: 50, bottom: 200, left: 5, right: 5, front: 450 } },
    { id: "vaillant_pro", category: "boiler", label: "Vaillant ecoTEC Pro", w: 440, h: 720, d: 340, clearance: { top: 165, bottom: 150, left: 5, right: 5, front: 600 } },
    { id: "vaillant_pure", category: "boiler", label: "Vaillant ecoTEC Pure", w: 390, h: 700, d: 320, clearance: { top: 165, bottom: 150, left: 5, right: 5, front: 600 } },
    { id: "glowworm", category: "boiler", label: "Glow-worm Energy", w: 390, h: 700, d: 280, clearance: { top: 150, bottom: 150, left: 5, right: 5, front: 600 } },
    { id: "viessmann_050", category: "boiler", label: "Viessmann 050-W", w: 400, h: 700, d: 300, clearance: { top: 200, bottom: 200, left: 5, right: 5, front: 450 } },

    // --- RADIATORS ---
    { id: "rad_600_1000", category: "radiator", label: "Type 22 (600x1000)", w: 1000, h: 600, d: 100, clearance: { top: 0, bottom: 150, left: 150, right: 150, front: 150 } },
    { id: "rad_600_600",  category: "radiator", label: "Type 22 (600x600)", w: 600, h: 600, d: 100, clearance: { top: 0, bottom: 150, left: 150, right: 150, front: 150 } },
    { id: "rad_custom",   category: "radiator", label: "Custom Size...", w: 1000, h: 600, d: 100, clearance: { top: 0, bottom: 150, left: 150, right: 150, front: 150 } },
    
    // --- CYLINDERS ---
    { id: "cyl_std",  category: "cylinder", label: "Standard (150L)", w: 550, h: 1045, d: 550, clearance: { top: 300, bottom: 300, left: 300, right: 300, front: 300 } },
    { id: "cyl_slim", category: "cylinder", label: "Slimline (150L)", w: 475, h: 1300, d: 475, clearance: { top: 300, bottom: 300, left: 300, right: 300, front: 300 } }
];

// ==========================================
// üëÅÔ∏è VISION SYSTEM (Improved Marker Detection)
// ==========================================
class VisionSystem {
    constructor() {
        this.ready = false;
        this.scale = 0.5;
    }

    init(video) {
        // Initialize Mats with scaled dimensions to match canvas size
        const w = Math.floor(video.videoWidth * this.scale);
        const h = Math.floor(video.videoHeight * this.scale);

        this.src = new cv.Mat(h, w, cv.CV_8UC4);
        this.gray = new cv.Mat();
        this.blurred = new cv.Mat();
        this.binary = new cv.Mat();
        this.contours = new cv.MatVector();
        this.hierarchy = new cv.Mat();
        this.ready = true;
    }

    findMarker(video, markerSize) {
        if(!this.ready) return null;
        const w = Math.floor(video.videoWidth * this.scale);
        const h = Math.floor(video.videoHeight * this.scale);

        if(!this._ctx) {
            const c = document.createElement('canvas');
            c.width = w; c.height = h;
            this._ctx = c.getContext('2d', {willReadFrequently:true});
        }

        // Ensure Mat dimensions match canvas dimensions
        if(this.src.cols !== w || this.src.rows !== h) {
            this.src.delete();
            this.src = new cv.Mat(h, w, cv.CV_8UC4);
        }

        this._ctx.drawImage(video, 0, 0, w, h);

        this.src.data.set(this._ctx.getImageData(0,0,w,h).data);
        cv.cvtColor(this.src, this.gray, cv.COLOR_RGBA2GRAY);
        
        // Apply Gaussian blur to reduce noise
        const ksize = new cv.Size(5, 5);
        cv.GaussianBlur(this.gray, this.blurred, ksize, 0);
        
        // Use Otsu's thresholding for better binary conversion
        cv.threshold(this.blurred, this.binary, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
        
        // Find contours
        cv.findContours(this.binary, this.contours, this.hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        let bestPose = null;
        let maxArea = 0;
        const minArea = 800;
        const maxArea_limit = (w * h) * 0.7;

        for (let i = 0; i < this.contours.size(); ++i) {
            let cnt = this.contours.get(i);
            let area = cv.contourArea(cnt);
            
            if (area > minArea && area < maxArea_limit) {
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
                
                if (approx.rows === 4 && cv.isContourConvex(approx)) {
                    // Check if it's roughly square by comparing aspect ratio
                    const rect = cv.boundingRect(approx);
                    const aspectRatio = Math.max(rect.width, rect.height) / Math.min(rect.width, rect.height);
                    
                    // Accept markers with aspect ratio <= 1.4 (roughly square)
                    if (aspectRatio <= 1.4 && area > maxArea) {
                        maxArea = area;
                        bestPose = this._getPose(approx, video.videoWidth, video.videoHeight, this.scale, markerSize);
                    }
                }
                approx.delete();
            }
        }
        return bestPose;
    }

    _getPose(approx, vw, vh, scale, markerSize) {
        const c = [];
        for(let j=0; j<8; j+=2) c.push({x: approx.data32S[j]/scale, y: approx.data32S[j+1]/scale});
        
        // Calculate marker width in pixels (average of all four edges)
        const wPx = (
            Math.hypot(c[0].x-c[1].x, c[0].y-c[1].y) +
            Math.hypot(c[1].x-c[2].x, c[1].y-c[2].y) +
            Math.hypot(c[2].x-c[3].x, c[2].y-c[3].y) +
            Math.hypot(c[3].x-c[0].x, c[3].y-c[0].y)
        ) / 4;
        
        // Calculate pose using pinhole camera model
        const vFovRad = 60 * Math.PI / 180;
        const focal = (vh / 2) / Math.tan(vFovRad / 2);
        const z = -(markerSize * focal) / wPx;
        
        // Calculate center of marker (average of all corners)
        const cx = (c[0].x + c[1].x + c[2].x + c[3].x) / 4;
        const cy = (c[0].y + c[1].y + c[2].y + c[3].y) / 4;
        
        // Convert to 3D position
        const x = (cx - vw/2) * (Math.abs(z)/focal);
        const y = (cy - vh/2) * (Math.abs(z)/focal) * -1;
        
        return { x, y, z };
    }
}

// ==========================================
// üé® GRAPHICS (Technical Stencils)
// ==========================================
class GraphicsEngine {
    constructor(canvas) {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        this.renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.root = new THREE.Group();
        this.scene.add(this.root);
        this.stencil = null;
    }

    setStencil(data) {
        if(this.stencil) this.root.remove(this.stencil);
        this.stencil = new THREE.Group();
        
        if(data.type === 'flue') {
            this._createRadial(data);
        } else {
            this._createBox(data);
        }
        
        this.stencil.position.x = 150; 
        this.root.add(this.stencil);
    }

    _createBox(data) {
        // Clearance Red Zone calculations
        let clearanceTop, clearanceBottom, clearanceLeft, clearanceRight;
        
        if (typeof data.clearance === 'object' && data.clearance !== null && !Array.isArray(data.clearance)) {
            clearanceTop = data.clearance.top || 0;
            clearanceBottom = data.clearance.bottom || 0;
            clearanceLeft = data.clearance.left || 0;
            clearanceRight = data.clearance.right || 0;
        } else {
            clearanceTop = clearanceBottom = clearanceLeft = clearanceRight = data.clearance || 0;
        }
        
        const zW = data.w + clearanceLeft + clearanceRight;
        const zH = data.h + clearanceTop + clearanceBottom;
        
        const offsetX = (clearanceRight - clearanceLeft) / 2;
        const offsetY = (clearanceTop - clearanceBottom) / 2;
        
        // 1. Draw Clearance Zone (Red Outline)
        const zoneGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(zW, zH, 5));
        const zoneMesh = new THREE.LineSegments(zoneGeo, new THREE.LineBasicMaterial({ color: 0xe30613 }));
        zoneMesh.position.set(offsetX, offsetY, 0);
        this.stencil.add(zoneMesh);

        // 2. Draw Appliance (Blue Outline)
        const boxGeo = new THREE.BoxGeometry(data.w, data.h, 5);
        const boxEdges = new THREE.EdgesGeometry(boxGeo);
        this.stencil.add(new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0x005eb8 })));

        // 3. Add transparent fill to clearance zone for better visual clarity
        const zoneFillGeo = new THREE.PlaneGeometry(zW, zH);
        const zoneFillMat = new THREE.MeshBasicMaterial({ color: 0xe30613, opacity: 0.1, transparent: true, side: THREE.DoubleSide });
        const zoneFillMesh = new THREE.Mesh(zoneFillGeo, zoneFillMat);
        zoneFillMesh.position.set(offsetX, offsetY, -2);
        this.stencil.add(zoneFillMesh);

        // 4. Hatching clipped to the Clearance Zone (The full red box)
        const hatchPoints = [];
        const startX = -zW/2 + offsetX, endX = zW/2 + offsetX;
        const startY = -zH/2 + offsetY, endY = zH/2 + offsetY;

        // Diagonal hatching lines (45 degrees)
        for(let x = startX - zH; x < endX + zH; x += 40) {
            // Line from (x, startY) to (x + zH, endY)
            hatchPoints.push(new THREE.Vector3(x, startY, 0));
            hatchPoints.push(new THREE.Vector3(x + zH, endY, 0));
        }
        
        const hatchMat = new THREE.LineBasicMaterial({ color: 0xe30613, opacity: 0.5, transparent: true });
        this.stencil.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(hatchPoints), hatchMat));
    }

    _createRadial(data) {
        const ring = new THREE.Mesh(new THREE.RingGeometry(0, data.radius, 32), new THREE.MeshBasicMaterial({color:0x333333}));
        const zone = new THREE.Mesh(new THREE.RingGeometry(data.radius, data.clearance, 32), new THREE.MeshBasicMaterial({color:0xe30613, opacity:0.3, transparent:true, side:THREE.DoubleSide}));
        this.stencil.add(ring, zone);
    }

    render() { this.renderer.render(this.scene, this.camera); }
}

// ==========================================
// üì± CONTROLLER
// ==========================================
const App = {
    markerSize: 45,
    vision: new VisionSystem(),
    graphics: null,
    locked: false,
    cvReady: false, // NEW: Flag to track OpenCV status

    onCvLoaded: function() {
        console.log("OpenCV script loaded, waiting for initialization...");
        const startTime = Date.now();
        const timeout = 10000; // 10 seconds timeout

        // Wait for OpenCV's internal initialization to complete (cv.aruco will exist)
        const checkCvReady = () => {
            const elapsed = Date.now() - startTime;

            // Check for timeout
            if (elapsed > timeout) {
                console.error("OpenCV initialization timeout after " + (elapsed/1000).toFixed(1) + "s");
                console.error("cv exists:", typeof cv !== 'undefined');
                console.error("cv.aruco exists:", typeof cv !== 'undefined' && typeof cv.aruco !== 'undefined');

                const startBtn = document.getElementById('start-camera-btn');
                const generateBtn = document.getElementById('generate-markers-btn');
                if (startBtn) {
                    startBtn.textContent = 'OpenCV Timeout (See Console)';
                    startBtn.style.background = '#e30613';
                }
                if (generateBtn) {
                    generateBtn.textContent = 'OpenCV Timeout (See Console)';
                    generateBtn.style.background = '#e30613';
                }

                alert("OpenCV failed to initialize after 10 seconds.\n\nPossible causes:\n‚Ä¢ Slow internet connection\n‚Ä¢ Script blocked by browser/firewall\n‚Ä¢ CDN unavailable\n\nCheck browser console (F12) for details.");
                return;
            }

            if (typeof cv !== 'undefined' && cv.aruco) {
                this.cvReady = true;
                this.updateModels();

                // Enable buttons and update text
                const startBtn = document.getElementById('start-camera-btn');
                const generateBtn = document.getElementById('generate-markers-btn');
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Camera';
                }
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate & Print (43mm)';
                }

                console.log("‚úì OpenCV ready after " + (elapsed/1000).toFixed(1) + "s");
            } else {
                // Log progress every 2 seconds
                if (elapsed % 2000 < 100) {
                    console.log("Waiting for OpenCV... (" + (elapsed/1000).toFixed(1) + "s) - cv:", typeof cv !== 'undefined', "cv.aruco:", typeof cv !== 'undefined' && typeof cv.aruco !== 'undefined');
                }
                // Check again after a short delay
                setTimeout(checkCvReady, 100);
            }
        };
        checkCvReady();
    },
    
    onCvError: function() {
        console.error("‚ùå Failed to load OpenCV.js from CDN");
        console.error("URL attempted: https://docs.opencv.org/4.5.2/opencv.js");
        console.error("This usually means:");
        console.error("  ‚Ä¢ No internet connection");
        console.error("  ‚Ä¢ CDN is blocked by firewall/browser");
        console.error("  ‚Ä¢ CDN server is down");

        // Update button states to show error
        const startBtn = document.getElementById('start-camera-btn');
        const generateBtn = document.getElementById('generate-markers-btn');
        if (startBtn) {
            startBtn.textContent = 'Network Error (Check Console)';
            startBtn.style.background = '#e30613';
        }
        if (generateBtn) {
            generateBtn.textContent = 'Network Error (Check Console)';
            generateBtn.style.background = '#e30613';
        }

        alert("‚ùå Failed to load OpenCV library from CDN.\n\nPossible solutions:\n‚Ä¢ Check your internet connection\n‚Ä¢ Disable browser extensions (ad blockers)\n‚Ä¢ Try a different network\n‚Ä¢ Host opencv.js locally (see console)\n\nFor local hosting instructions, open browser console (F12).");

        console.log("\nüìò TO HOST OPENCV.JS LOCALLY:");
        console.log("1. Download: https://docs.opencv.org/4.5.2/opencv.js");
        console.log("2. Place in project root or 'lib/' folder");
        console.log("3. Change line 8 to: <script async src=\"opencv.js\" ...>");
        console.log("4. Serve via local server (python -m http.server 8000)");
    },

    // Handle marker size selection change
    onSizeChange: function() {
        const sizeSelect = document.getElementById('input-size');
        const customContainer = document.getElementById('custom-size-container');
        
        if (sizeSelect.value === 'custom') {
            customContainer.classList.remove('hidden');
        } else {
            customContainer.classList.add('hidden');
        }
    },

    // Handle model selection change
    onModelChange: function() {
        const modelSelect = document.getElementById('input-type');
        const customRadiatorContainer = document.getElementById('custom-radiator-container');
        const index = parseInt(modelSelect.value, 10);
        
        // Check if the selected model is the custom radiator
        if (!isNaN(index) && index >= 0 && index < APPLIANCE_DB.length) {
            const selectedItem = APPLIANCE_DB[index];
            if (selectedItem.id === 'rad_custom') {
                customRadiatorContainer.classList.remove('hidden');
            } else {
                customRadiatorContainer.classList.add('hidden');
            }
        } else {
            customRadiatorContainer.classList.add('hidden');
        }
    },

    // Filters the list based on category
    updateModels: function() {
        const category = document.getElementById('input-category').value;
        const modelSelect = document.getElementById('input-type');
        
        // Clear existing options
        modelSelect.innerHTML = "";

        // Filter DB and create new options
        APPLIANCE_DB.forEach((item, index) => {
            if (item.category === category) {
                const opt = document.createElement('option');
                // We store the array INDEX as the value so we can look it up easily later
                opt.value = index; 
                opt.text = item.label;
                modelSelect.appendChild(opt);
            }
        });
        
        // Trigger model change to update custom input visibility
        this.onModelChange();
    },

    startSession: async function() {
        // Guard clause: ensure CV is ready before starting the session
        if (!this.cvReady) {
            alert("OpenCV is still loading. Please wait a moment.");
            return;
        }
        
        const sizeSelect = document.getElementById('input-size').value;
        
        // Get marker size from either preset or custom input
        if (sizeSelect === 'custom') {
            const customSize = parseInt(document.getElementById('custom-size-input').value, 10);
            if (isNaN(customSize) || customSize < 10 || customSize > 500) {
                alert('Please enter a valid marker size between 10 and 500 millimeters (whole numbers only)');
                return;
            }
            this.markerSize = customSize;
        } else {
            this.markerSize = parseInt(sizeSelect, 10);
        }
        
        const index = parseInt(document.getElementById('input-type').value, 10);
        
        // Validate index
        if(isNaN(index) || index < 0 || index >= APPLIANCE_DB.length) {
            console.error('Invalid appliance selection');
            return;
        }
        
        let data = APPLIANCE_DB[index];
        
        // Handle custom radiator dimensions
        if (data.id === 'rad_custom') {
            const customWidth = parseInt(document.getElementById('custom-radiator-width').value, 10);
            const customHeight = parseInt(document.getElementById('custom-radiator-height').value, 10);
            
            if (isNaN(customWidth) || customWidth < 100 || customWidth > 3000) {
                alert('Please enter a valid radiator width between 100 and 3000 mm');
                return;
            }
            
            if (isNaN(customHeight) || customHeight < 100 || customHeight > 2000) {
                alert('Please enter a valid radiator height between 100 and 2000 mm');
                return;
            }
            
            // Create a copy of the data with custom dimensions
            data = { ...data, w: customWidth, h: customHeight };
        }

        document.getElementById('menu-panel').classList.add('hidden');
        document.getElementById('ar-generator-panel').classList.add('hidden');
        document.getElementById('controls-panel').classList.remove('hidden');
        document.getElementById('status-pill').classList.remove('hidden');
        document.getElementById('status-pill').textContent = "üîç Point at Marker...";

        const video = document.getElementById('camera-layer');
        video.srcObject = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'environment', width: { ideal: 1280 } } 
        });

        this.graphics = new GraphicsEngine(document.getElementById('ar-layer'));
        this.graphics.setStencil(data);
        this.setupTouch();
        this.vision.init(video);
        this.loop();
    },

    loop: function() {
        requestAnimationFrame(this.loop.bind(this));
        const video = document.getElementById('camera-layer');
        if(video.readyState !== 4) return;
        
        this.graphics.render();

        if(!this.locked) {
            const pose = this.vision.findMarker(video, this.markerSize);
            if(pose) {
                const t = this.graphics.root.position;
                t.x += (pose.x - t.x) * 0.2;
                t.y += (pose.y - t.y) * 0.2;
                t.z += (pose.z - t.z) * 0.2;
                document.getElementById('status-pill').textContent = "‚úì Locked";
                document.getElementById('status-pill').className = "locked";
            } else {
                document.getElementById('status-pill').textContent = "üîç Looking...";
                document.getElementById('status-pill').className = "";
            }
        }
    },

    setupTouch: function() {
        const pad = document.getElementById('touch-pad');
        let drag=false, sx=0, sy=0, ox=0, oy=0;
        pad.addEventListener('touchstart', e => {
            if(this.locked) return;
            drag=true; sx=e.touches[0].clientX; sy=e.touches[0].clientY;
            ox=this.graphics.stencil.position.x; oy=this.graphics.stencil.position.y;
        });
        pad.addEventListener('touchmove', e => {
            if(!drag) return;
            const scale = Math.abs(this.graphics.root.position.z)/1000 * 2.5;
            this.graphics.stencil.position.x = ox + (e.touches[0].clientX-sx)*scale;
            this.graphics.stencil.position.y = oy - (e.touches[0].clientY-sy)*scale;
        });
        pad.addEventListener('touchend', () => drag=false);
    },

    lockView: function() {
        this.locked = true;
        document.getElementById('camera-layer').pause();
        document.getElementById('controls-panel').classList.add('hidden');
        document.getElementById('result-panel').classList.remove('hidden');
    },
    resetObject: function() { this.graphics.stencil.position.set(150,0,0); },
    
    generateArUcoMarkers: function() {
        // Guard clause: ensure CV is ready
        if (!this.cvReady || typeof cv === 'undefined' || typeof cv.aruco === 'undefined') {
            alert("OpenCV is still loading. Please wait a moment.");
            return;
        }

        const dict = new cv.aruco.Dictionary(cv.aruco.DICT_4X4_50);
        const markerSizePx = 300;
        const markerCount = 12;
        const printArea = document.getElementById('marker-print-area');
        printArea.innerHTML = '';
        printArea.classList.remove('hidden');

        try {
            for (let i = 0; i < markerCount; i++) {
                const container = document.createElement('div');
                container.className = 'marker-container';
                
                const canvas = document.createElement('canvas');
                canvas.width = markerSizePx;
                canvas.height = markerSizePx;
                container.appendChild(canvas);
                
                let markerMat = new cv.Mat(markerSizePx, markerSizePx, cv.CV_8UC1);
                
                try {
                    cv.aruco.drawMarker(dict, i, markerSizePx, markerMat, 1);
                    cv.imshow(canvas, markerMat);
                } finally {
                    markerMat.delete();
                }
                
                printArea.appendChild(container);
            }
            
            // Initiate printing after a short delay
            setTimeout(() => window.print(), 100);
        } catch (error) {
            console.error('Error generating markers:', error);
            alert('Failed to generate markers. Please try again.');
            printArea.classList.add('hidden');
        }
    },
    
    // UPDATED FUNCTION: Correctly captures video with 'object-fit: cover' behavior
    captureImage: function() {
        const canvas = document.createElement('canvas');
        const video = document.getElementById('camera-layer');
        const arCanvas = document.getElementById('ar-layer');

        // Use window dimensions to match the AR canvas size (which is full screen)
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');

        // --- Calculate video draw parameters to replicate object-fit: cover ---
        const videoAspect = video.videoWidth / video.videoHeight;
        const canvasAspect = canvas.width / canvas.height;

        let drawWidth, drawHeight, offsetX, offsetY;

        if (videoAspect > canvasAspect) {
            // Video is wider than canvas ratio (covers height, cropped horizontally)
            drawHeight = canvas.height;
            drawWidth = drawHeight * videoAspect;
            offsetX = (canvas.width - drawWidth) / 2;
            offsetY = 0;
        } else {
            // Video is taller than canvas ratio (covers width, cropped vertically)
            drawWidth = canvas.width;
            drawHeight = drawWidth / videoAspect;
            offsetX = 0;
            offsetY = (canvas.height - drawHeight) / 2;
        }

        // Draw the video frame with the correct scale and offset
        ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);

        // Draw the AR overlay on top
        ctx.drawImage(arCanvas, 0, 0);

        // Convert to blob and download
        canvas.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().split('.')[0].replace(/[:.]/g, '-');
            a.download = 'clearance-check-' + timestamp + '.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');
    }
};
</script>
</body>
</html>
