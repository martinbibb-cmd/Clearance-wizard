<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#005eb8">
    <meta name="description" content="AR Clearance Checker for Heating Appliances">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Clearance Genie">
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">
    <title>Clearance Genie: Pro (4-Marker)</title>
    
    <script>
        // OpenCV.js loading with CDN fallback
        (function() {
            const script = document.createElement('script');
            script.async = true;
            script.src = './opencv.js';
            script.onload = function() {
                console.log('OpenCV loaded from local file');
                if (typeof App !== 'undefined' && App.onCvLoaded) {
                    App.onCvLoaded();
                }
            };
            script.onerror = function() {
                console.log('Local opencv.js not found, falling back to CDN...');
                const cdnScript = document.createElement('script');
                cdnScript.async = true;
                cdnScript.src = 'https://docs.opencv.org/4.5.2/opencv.js';
                cdnScript.onload = function() {
                    console.log('OpenCV loaded from CDN');
                    if (typeof App !== 'undefined' && App.onCvLoaded) {
                        App.onCvLoaded();
                    }
                };
                cdnScript.onerror = function() {
                    console.error('Failed to load OpenCV from both local and CDN sources');
                    if (typeof App !== 'undefined' && App.onCvError) {
                        App.onCvError();
                    }
                };
                document.head.appendChild(cdnScript);
            };
            document.head.appendChild(script);
        })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root { --wb-blue: #005eb8; --wb-red: #e30613; }
        body { margin: 0; background: #000; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; }
        
        #camera-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #ar-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; display: flex; flex-direction: column; pointer-events: none; }
        
        .interactive { pointer-events: auto; }
        .card { background: rgba(255,255,255,0.95); padding: 20px; border-radius: 12px; margin: 20px auto; width: 90%; max-width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .hidden { display: none !important; }
        
        
        h1 { margin: 0 0 15px 0; font-size: 1.2rem; color: #333; text-align: center; }
        label { display: block; font-size: 0.8rem; color: #666; margin-bottom: 5px; font-weight: 700; text-transform: uppercase; }
        select, button, input[type="number"] { width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #ccc; margin-bottom: 15px; font-size: 1rem; background: white; }
        
        button.primary { background: var(--wb-blue); color: white; border: none; font-weight: 600; cursor: pointer; }
        button.primary:disabled { background: #999; cursor: not-allowed; opacity: 0.7; } /* Disabled button styling */
        
        #status-pill { 
            align-self: center; margin-top: 50px; padding: 10px 25px; border-radius: 30px; 
            font-size: 0.9rem; font-weight: 600; background: rgba(255,255,255,0.9); color: #333;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
        }
        #status-pill.locked { background: var(--wb-red); color: white; }

        .control-bar { margin-top: auto; padding: 20px; display: flex; gap: 15px; justify-content: center; background: linear-gradient(to top, rgba(0,0,0,0.5), transparent); }
        .btn-round { width: 60px; height: 60px; border-radius: 50%; border: none; font-size: 1.5rem; background: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer; }
        
        #touch-pad { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; touch-action: none; }
    </style>
</head>
<body>

    <video id="camera-layer" autoplay playsinline muted></video>
    <canvas id="ar-layer"></canvas>
    <div id="touch-pad"></div>

    <div id="ui-layer">
        <div id="status-pill">Waiting for OpenCV...</div>

        <div id="setup-card" class="card interactive">
            <h1>Pro Mini-App</h1>
            <p style="text-align: center; color: #666; margin-bottom: 20px; font-size: 0.95rem;">
                ‚Ä¢ Use 4 markers (IDs 1-4)<br>
                ‚Ä¢ Marker size: 90mm<br>
                ‚Ä¢ Scaled for 4000 Unit (724mm)
            </p>
            <button id="start-camera-btn" class="primary" onclick="App.start()" disabled>Loading OpenCV...</button>
        </div>



    </div>

<script>
// ==========================================
// üëÅÔ∏è PRO VISION SYSTEM (Multi-Marker)
// ==========================================
class ProVision {
    constructor() {
        this.markerSize = 90; // Fixed 90mm per Pro requirement
        this.dictionary = null;
        this.params = null;
    }

    init() {
        this.dictionary = new cv.aruco_Dictionary(cv.DICT_4X4_50);
        this.params = new cv.aruco_DetectorParameters();
    }

    detect(video, srcMat, grayMat) {
        let corners = new cv.MatVector();
        let ids = new cv.Mat();
        cv.detectMarkers(grayMat, this.dictionary, corners, ids, this.params);

        if (ids.rows > 0) {
            // We use the first detected marker as our primary "Anchor" (usually ID 1)
            // But we use its specific 90mm size to set the scene scale
            const idx = 0;
            const markerId = ids.data32S[0]; 
            const markerCorners = corners.get(idx);
            
            // Basic Pinhole Math to get Z-depth based on 90mm
            const vh = video.videoHeight;
            const focal = (vh / 2) / Math.tan((60 * Math.PI / 180) / 2);
            
            // Get pixel width of the 90mm marker
            const p1 = {x: markerCorners.data32F[0], y: markerCorners.data32F[1]};
            const p2 = {x: markerCorners.data32F[2], y: markerCorners.data32F[3]};
            const pxWidth = Math.hypot(p1.x - p2.x, p1.y - p2.y);
            
            const z = -(this.markerSize * focal) / pxWidth;
            const cx = (p1.x + p2.x) / 2;
            const cy = (p1.y + p2.y) / 2;
            
            const x = (cx - video.videoWidth/2) * (Math.abs(z)/focal);
            const y = (cy - vh/2) * (Math.abs(z)/focal) * -1;

            corners.delete();
            ids.delete();
            return { x, y, z, id: markerId };
        }
        
        corners.delete();
        ids.delete();
        return null;
    }
}

// ==========================================
// üé® PRO GRAPHICS (Scaled for 724mm)
// ==========================================
class ProGraphics {
    constructor(canvas) {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        this.renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.root = new THREE.Group();
        this.scene.add(this.root);
        
        // CREATE THE 724mm BOILER BOX (Worcester 4000)
        // Blue box = 400 wide, 724 tall, 310 deep
        const geo = new THREE.BoxGeometry(400, 724, 310);
        const mat = new THREE.MeshBasicMaterial({ color: 0x005eb8, wireframe: true });
        const box = new THREE.Mesh(geo, mat);
        box.position.set(0, -362, -155); // Anchor to Top-Center of marker
        this.root.add(box);
    }

    render() { 
        this.renderer.render(this.scene, this.camera); 
    }
}

// ==========================================
// üì± PRO APP
// ==========================================
const App = {
    vision: new ProVision(),
    graphics: null,
    
    onCvLoaded: function() {
        console.log("OpenCV script file loaded successfully. Starting internal initialization check.");
        
        const checkCvReady = () => {
            // Check 1: Global cv object exists, Check 2: ArUco is available
            if (typeof cv !== 'undefined' && cv.Mat && cv.aruco_Dictionary) {
                // Enable button and update text
                const startBtn = document.getElementById('start-camera-btn');
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Calibration';
                }
                document.getElementById('status-pill').textContent = "OpenCV Ready";
                console.log("‚úì OpenCV Ready");
            } else {
                setTimeout(checkCvReady, 100);
            }
        };
        checkCvReady();
    },
    
    // Core function to handle failed OpenCV script download (network error)
    onCvError: function() {
        document.getElementById('status-pill').textContent = "Failed to load OpenCV";
        const startBtn = document.getElementById('start-camera-btn');
        if (startBtn) {
            startBtn.textContent = 'Initialization Failed';
            startBtn.style.background = '#e30613';
            startBtn.disabled = true;
        }
        alert("OpenCV script failed to download.\n\nCheck browser console (F12) for details.");
    },

    start: async function() {
        document.getElementById('setup-card').style.display = 'none';
        const video = document.getElementById('camera-layer');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        video.srcObject = stream;

        // Setup Three.js
        const canvas = document.getElementById('ar-layer');
        this.graphics = new ProGraphics(canvas);

        this.vision.init();
        this.run();
    },

    run: function() {
        requestAnimationFrame(() => this.run());
        const video = document.getElementById('camera-layer');
        if (video.readyState !== 4) return;

        // Process frame
        const canvas = document.createElement('canvas');
        canvas.width = 640; canvas.height = 480;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, 640, 480);
        
        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        const pose = this.vision.detect(video, src, gray);
        if (pose) {
            document.getElementById('status-pill').textContent = "ID " + pose.id + " Detected - Scaling to 90mm";
            this.graphics.root.position.set(pose.x, pose.y, pose.z);
        } else {
            document.getElementById('status-pill').textContent = "Looking for Markers 1-4...";
        }

        this.graphics.render();
        src.delete(); gray.delete();
    }
};

// ==========================================
// üì± PWA SERVICE WORKER REGISTRATION
// ==========================================
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
            .then((registration) => {
                console.log('‚úì Service Worker registered successfully:', registration.scope);
            })
            .catch((error) => {
                console.log('‚ùå Service Worker registration failed:', error);
            });
    });
}
</script>
</body>
</html>
