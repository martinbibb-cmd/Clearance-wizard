<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="theme-color" content="#005eb8">
    <meta name="description" content="AR Clearance Checker for Heating Appliances">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Clearance Genie">
    <link rel="manifest" href="./manifest.json?v=2.1.0">
    <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
    <link rel="apple-touch-icon" href="./icon-192.png">
    <title>Clearance Genie: Final</title>
    
    <script>
        // OpenCV.js loading with CDN fallback
        (function() {
            const script = document.createElement('script');
            script.async = true;
            script.src = './opencv.js';
            script.onload = function() {
                console.log('OpenCV loaded from local file');
                if (typeof App !== 'undefined' && App.onCvLoaded) {
                    App.onCvLoaded();
                }
            };
            script.onerror = function() {
                console.log('Local opencv.js not found, falling back to CDN...');
                const cdnScript = document.createElement('script');
                cdnScript.async = true;
                cdnScript.src = 'https://docs.opencv.org/4.5.2/opencv.js';
                cdnScript.onload = function() {
                    console.log('OpenCV loaded from CDN');
                    if (typeof App !== 'undefined' && App.onCvLoaded) {
                        App.onCvLoaded();
                    }
                };
                cdnScript.onerror = function() {
                    console.error('Failed to load OpenCV from both local and CDN sources');
                    if (typeof App !== 'undefined' && App.onCvError) {
                        App.onCvError();
                    }
                };
                document.head.appendChild(cdnScript);
            };
            document.head.appendChild(script);
        })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="./apriltag.js"></script>

    <style>
        :root { --wb-blue: #005eb8; --wb-red: #e30613; }
        body { margin: 0; background: #000; font-family: -apple-system, system-ui, sans-serif; overflow: hidden; }
        
        #camera-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #ar-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; display: flex; flex-direction: column; pointer-events: none; }
        
        .interactive { pointer-events: auto; }
        .card { background: rgba(255,255,255,0.95); padding: 20px; border-radius: 12px; margin: 20px auto; width: 90%; max-width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-height: calc(100vh - 40px); overflow-y: auto; -webkit-overflow-scrolling: touch; }
        .hidden { display: none !important; }
        
        
        h1 { margin: 0 0 15px 0; font-size: 1.2rem; color: #333; text-align: center; }
        label { display: block; font-size: 0.8rem; color: #666; margin-bottom: 5px; font-weight: 700; text-transform: uppercase; }
        select, button, input[type="number"] { width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #ccc; margin-bottom: 15px; font-size: 1rem; background: white; }
        
        button.primary { background: var(--wb-blue); color: white; border: none; font-weight: 600; cursor: pointer; }
        button.primary:disabled { background: #999; cursor: not-allowed; opacity: 0.7; } /* Disabled button styling */
        
        #status-pill { 
            align-self: center; margin-top: 50px; padding: 10px 25px; border-radius: 30px; 
            font-size: 0.9rem; font-weight: 600; background: rgba(255,255,255,0.9); color: #333;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
        }
        #status-pill.locked { background: var(--wb-red); color: white; }

        .control-bar { margin-top: auto; padding: 20px; display: flex; gap: 15px; justify-content: center; background: linear-gradient(to top, rgba(0,0,0,0.5), transparent); }
        .btn-round { width: 60px; height: 60px; border-radius: 50%; border: none; font-size: 1.5rem; background: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer; }
        
        #touch-pad { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; touch-action: none; }
    </style>
</head>
<body>

    <video id="camera-layer" autoplay playsinline muted></video>
    <canvas id="ar-layer"></canvas>
    <canvas id="marker-feedback-layer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none;"></canvas>
    <div id="touch-pad"></div>

    <div id="ui-layer">
        <div id="status-pill" class="hidden">Initializing...</div>

        <div id="welcome-panel" class="card interactive">
            <h1>üî• Clearance Genie</h1>
            <p style="text-align: center; color: #666; margin-bottom: 20px; font-size: 0.95rem;">
                AR Clearance Checker for Heating Appliances
            </p>

            <!-- Quick Start Steps (Visual & Minimal) -->
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
                <div style="text-align: center; padding: 15px; background: #f0f7ff; border-radius: 8px;">
                    <div style="font-size: 2rem; margin-bottom: 5px;">üìê</div>
                    <div style="font-size: 0.75rem; font-weight: 600; color: #333;">Print Marker</div>
                </div>
                <div style="text-align: center; padding: 15px; background: #f0f7ff; border-radius: 8px;">
                    <div style="font-size: 2rem; margin-bottom: 5px;">üì±</div>
                    <div style="font-size: 0.75rem; font-weight: 600; color: #333;">Point Camera</div>
                </div>
                <div style="text-align: center; padding: 15px; background: #f0f7ff; border-radius: 8px;">
                    <div style="font-size: 2rem; margin-bottom: 5px;">üëÅÔ∏è</div>
                    <div style="font-size: 0.75rem; font-weight: 600; color: #333;">View AR</div>
                </div>
            </div>

            <!-- Collapsible Instructions -->
            <details style="background: #f9f9f9; padding: 12px; border-radius: 8px; margin-bottom: 15px; cursor: pointer;">
                <summary style="font-weight: 600; color: var(--wb-blue); cursor: pointer;">üìã How to Use (tap to expand)</summary>
                <div style="margin-top: 10px; font-size: 0.85rem; line-height: 1.5; color: #444;">
                    <p style="margin: 8px 0;"><strong>1. Choose Mode:</strong> Single marker or multi-marker (4 or 5)</p>
                    <p style="margin: 8px 0;"><strong>2. Configure:</strong> Select appliance type and marker size</p>
                    <p style="margin: 8px 0;"><strong>3. Scan:</strong> Point camera at marker(s)</p>
                    <p style="margin: 8px 0;"><strong>4. Capture:</strong> Lock view and save image</p>
                </div>
            </details>

            <!-- Marker Info -->
            <details style="background: #f0f0f0; padding: 12px; border-radius: 8px; margin-bottom: 15px; cursor: pointer;">
                <summary style="font-weight: 600; color: #666; cursor: pointer;">üìç Get Markers</summary>
                <div style="margin-top: 10px; font-size: 0.8rem; color: #666;">
                    <p style="margin: 5px 0;"><strong>ArUco markers (current):</strong> Download (DICT_4X4_50) from <a href="https://chev.me/arucogen/" target="_blank" style="color: var(--wb-blue);">arucogen</a></p>
                    <p style="margin: 5px 0;"><strong>‚ú® AprilTag markers (new!):</strong> <button onclick="App.showMarkerGenerator()" style="padding: 5px 10px; border: none; background: var(--wb-blue); color: white; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Generate AprilTag</button></p>
                    <p style="margin: 5px 0;">üí° <strong>Tip:</strong> Larger markers (190mm) = better tracking</p>
                    <p style="margin: 5px 0;">üìè <strong>Measure:</strong> BLACK SQUARE ONLY (no white border)</p>
                </div>
            </details>

            <button class="primary" onclick="App.showMainMenu()" style="margin-bottom: 10px; font-size: 1.1rem; padding: 15px;">üöÄ Get Started</button>
            
            <!-- Quick Links -->
            <div style="display: flex; gap: 10px; font-size: 0.75rem; justify-content: center; color: #666;">
                <a href="MARKER_GUIDE.md" target="_blank" style="color: var(--wb-blue);">üìñ Marker Guide</a>
                <span>|</span>
                <a href="FUTURE_IMPROVEMENTS.md" target="_blank" style="color: var(--wb-blue);">üöÄ Roadmap</a>
                <span>|</span>
                <a href="README.md" target="_blank" style="color: var(--wb-blue);">‚ùì Help</a>
            </div>
        </div>

        <div id="menu-panel" class="card interactive hidden">
            <h1>üî• Clearance Genie</h1>

            <!-- Detection Mode with Visual Cards -->
            <label style="display: flex; align-items: center; gap: 5px;">
                üìê Detection Mode
            </label>
            <select id="input-detection-mode" onchange="App.onDetectionModeChange()" style="font-size: 0.95rem;">
                <option value="single">üìç Single Marker</option>
                <option value="4-marker">üìê 4-Marker (Boiler)</option>
                <option value="5-marker">ü™ü 5-Marker (Window)</option>
            </select>

            <!-- Marker Size -->
            <div id="single-marker-size-container">
                <label style="display: flex; align-items: center; gap: 5px;">
                    üìè Marker Size
                </label>
                <select id="input-size" onchange="App.onSizeChange()">
                    <option value="45">45mm</option>
                    <option value="53">53mm (Credit Card)</option>
                    <option value="148">148mm (A5)</option>
                    <option value="167">167mm (A4)</option>
                    <option value="190">190mm (Recommended) ‚≠ê</option>
                    <option value="custom">‚úèÔ∏è Custom...</option>
                </select>

                <div id="custom-size-container" class="hidden">
                    <input type="number" id="custom-size-input" min="10" max="500" step="1" placeholder="Custom size (mm)" aria-label="Custom marker size in millimeters">
                </div>
            </div>

            <div id="multi-marker-size-container" class="hidden">
                <label style="display: flex; align-items: center; gap: 5px;">
                    üìè Marker Size
                </label>
                <input type="number" id="multi-marker-size-input" min="10" max="500" step="1" value="90" placeholder="Size in mm" aria-label="Multi-marker size in millimeters">
            </div>

            <!-- Appliance Selection -->
            <label style="display: flex; align-items: center; gap: 5px;">
                üè≠ Appliance Type
            </label>
            <select id="input-category" onchange="App.updateModels()">
                <option value="boiler">üî• Boilers</option>
                <option value="flue">‚≠ï Flues</option>
                <option value="radiator">‚ô®Ô∏è Radiators</option>
                <option value="cylinder">üõ¢Ô∏è Cylinders</option>
            </select>

            <label style="display: flex; align-items: center; gap: 5px;">
                üè∑Ô∏è Model
            </label>
            <select id="input-type" onchange="App.onModelChange()">
            </select>

            <!-- Custom Radiator Dimensions -->
            <div id="custom-radiator-container" class="hidden">
                <label>Width (mm)</label>
                <input type="number" id="custom-radiator-width" min="100" max="3000" step="1" value="1000" placeholder="Width">
                
                <label>Height (mm)</label>
                <input type="number" id="custom-radiator-height" min="100" max="2000" step="1" value="600" placeholder="Height">
            </div>

            <!-- Advanced Options (Collapsible) -->
            <details style="margin-bottom: 15px;">
                <summary style="font-size: 0.85rem; color: #666; cursor: pointer; padding: 8px; background: #f5f5f5; border-radius: 6px;">‚öôÔ∏è Advanced Settings</summary>
                <div style="margin-top: 10px;">
                    <label style="font-size: 0.8rem;">Depth Offset (mm)</label>
                    <input type="number" id="manual-depth-offset" min="-1000" max="1000" step="10" value="0" placeholder="Fine-tune depth" aria-label="Manual depth adjustment">
                </div>
            </details>

            <button id="start-camera-btn" class="primary" onclick="App.startSession()" disabled style="font-size: 1.1rem; padding: 15px;">
                üì∑ Start Camera
            </button>
        </div>

        <div id="marker-generator-panel" class="card interactive hidden">
            <h1>üè∑Ô∏è AprilTag Generator</h1>
            <p style="text-align: center; color: #666; font-size: 0.9rem; margin-bottom: 20px;">
                Generate AprilTag markers for enhanced detection accuracy
            </p>

            <label>Tag Family</label>
            <select id="tag-family-select" style="margin-bottom: 15px;">
                <option value="36h11">tag36h11 (Recommended) ‚≠ê</option>
                <option value="25h9">tag25h9 (Smaller)</option>
                <option value="16h5">tag16h5 (Fastest)</option>
            </select>

            <label>Tag ID</label>
            <input type="number" id="tag-id-input" min="0" max="586" value="0" style="margin-bottom: 15px;" placeholder="Enter Tag ID (0-586)">

            <label>Marker Size (mm)</label>
            <select id="tag-size-select" style="margin-bottom: 15px;">
                <option value="90">90mm (Standard)</option>
                <option value="148">148mm (A5)</option>
                <option value="190">190mm (Recommended) ‚≠ê</option>
                <option value="custom">Custom...</option>
            </select>

            <div id="tag-custom-size-container" class="hidden" style="margin-bottom: 15px;">
                <input type="number" id="tag-custom-size-input" min="10" max="500" step="1" placeholder="Custom size (mm)">
            </div>

            <button class="primary" onclick="App.generateAprilTag()" style="margin-bottom: 10px;">
                üé® Generate Marker
            </button>

            <div id="marker-preview" class="hidden" style="text-align: center; margin: 20px 0;">
                <canvas id="marker-canvas" style="max-width: 100%; border: 1px solid #ccc; border-radius: 8px;"></canvas>
                <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: center;">
                    <button onclick="App.downloadMarker()" style="padding: 10px 20px; border: none; background: var(--wb-blue); color: white; border-radius: 6px; cursor: pointer;">
                        üíæ Download
                    </button>
                    <button onclick="App.printMarker()" style="padding: 10px 20px; border: none; background: #666; color: white; border-radius: 6px; cursor: pointer;">
                        üñ®Ô∏è Print
                    </button>
                </div>
            </div>

            <button onclick="App.hideMarkerGenerator()" style="background: #999; color: white; border: none; padding: 12px; border-radius: 6px; width: 100%; cursor: pointer;">
                ‚Üê Back
            </button>
        </div>

        <div id="controls-panel" class="control-bar interactive hidden">
            <button class="btn-round" onclick="App.resetObject()">‚Ü∫</button>
            <button class="btn-round" style="background: var(--wb-blue); color: white;" onclick="App.lockView()">üîí</button>
        </div>

        <div id="result-panel" class="control-bar interactive hidden">
            <button class="btn-round" onclick="App.unlockView()" aria-label="Unlock View / Reset Tracking" title="Unlock AR View and Re-enable Tracking">üîì</button>
            <button class="btn-round" style="background: var(--wb-blue); color: white;" onclick="App.captureImage()" aria-label="Capture AR view" title="Capture current AR view as image">üì∑</button>
            <button class="primary" style="max-width:200px;" onclick="App.startAgain()">Start Again</button>
        </div>
    </div>

<script>
// ==========================================
// üîß OPENCV LOADING STRATEGY
// ==========================================
// OpenCV.js is loaded asynchronously with automatic CDN fallback.
//
// Loading process:
// 1. First attempts to load from local ./opencv.js file (included in repository)
// 2. If local file not found, falls back to CDN: https://docs.opencv.org/4.5.2/opencv.js
// 3. onload fires -> App.onCvLoaded() starts polling for cv.Mat
// 4. Internal OpenCV initialization completes (cv.Mat becomes available)
// 5. Buttons are enabled and app is ready
//
// OpenCV.js is now bundled with the repository:
// - opencv.js is included in the project directory
// - No separate download required
// - CDN fallback is available as a backup
//
// Troubleshooting stuck on "Loading OpenCV...":
// - Open browser console (F12) to see diagnostic messages
// - Check Network tab to see if opencv.js loaded successfully
// - Look for error messages about blocked scripts or CORS issues
// - Ensure opencv.js file is present in the project directory
//
// Mobile considerations:
// - Large file size (8MB) may take longer on mobile networks
// - Some mobile browsers may restrict external script loading
// - CDN fallback available if local file loading fails
// ==========================================

// ==========================================
// üìö DATA: APPLIANCE DATABASE
// ==========================================
const APPLIANCE_DB = [
    // --- FLUES ---
    { id: "flue", category: "flue", label: "Standard Round Terminal", type: "flue", radius: 50, clearance: 300 },

    // --- BOILERS ---
    { id: "wb_4000", category: "boiler", label: "Worcester 4000 (Combi/System)", w: 400, h: 724, d: 310, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 600 } },
    { id: "wb_8000", category: "boiler", label: "Worcester 8000 (CDi/Si Compact)", w: 440, h: 780, d: 365, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 450 } },
    { id: "wb_ri",   category: "boiler", label: "Worcester Ri Compact", w: 390, h: 600, d: 270, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 600 } },
    { id: "wb_cdi",  category: "boiler", label: "Worcester CDi Compact", w: 390, h: 690, d: 310, clearance: { top: 170, bottom: 200, left: 5, right: 5, front: 450 } },
    { id: "ideal_logic", category: "boiler", label: "Ideal Logic+ / Max", w: 395, h: 700, d: 310, clearance: { top: 50, bottom: 200, left: 5, right: 5, front: 450 } },
    { id: "vaillant_pro", category: "boiler", label: "Vaillant ecoTEC Pro", w: 440, h: 720, d: 340, clearance: { top: 165, bottom: 150, left: 5, right: 5, front: 600 } },
    { id: "vaillant_pure", category: "boiler", label: "Vaillant ecoTEC Pure", w: 390, h: 700, d: 320, clearance: { top: 165, bottom: 150, left: 5, right: 5, front: 600 } },
    { id: "glowworm", category: "boiler", label: "Glow-worm Energy", w: 390, h: 700, d: 280, clearance: { top: 150, bottom: 150, left: 5, right: 5, front: 600 } },
    { id: "viessmann_050", category: "boiler", label: "Viessmann 050-W", w: 400, h: 700, d: 300, clearance: { top: 200, bottom: 200, left: 5, right: 5, front: 450 } },

    // --- RADIATORS ---
    { id: "rad_600_1000", category: "radiator", label: "Type 22 (600x1000)", w: 1000, h: 600, d: 100, clearance: { top: 0, bottom: 150, left: 150, right: 150, front: 150 } },
    { id: "rad_600_600",  category: "radiator", label: "Type 22 (600x600)", w: 600, h: 600, d: 100, clearance: { top: 0, bottom: 150, left: 150, right: 150, front: 150 } },
    { id: "rad_custom",   category: "radiator", label: "Custom Size...", w: 1000, h: 600, d: 100, clearance: { top: 0, bottom: 150, left: 150, right: 150, front: 150 } },
    
    // --- CYLINDERS ---
    { id: "cyl_std",  category: "cylinder", label: "Standard (150L)", w: 550, h: 1045, d: 550, clearance: { top: 300, bottom: 300, left: 300, right: 300, front: 300 } },
    { id: "cyl_slim", category: "cylinder", label: "Slimline (150L)", w: 475, h: 1300, d: 475, clearance: { top: 300, bottom: 300, left: 300, right: 300, front: 300 } }
];

// ==========================================
// üëÅÔ∏è VISION SYSTEM (ArUco Marker Detection)
// ==========================================
class VisionSystem {
    constructor() {
        this.ready = false;
        this.scale = 0.5;
        this.useAruco = true; // Use ArUco detection for better pose estimation
    }

    init(video) {
        // Initialize Mats with scaled dimensions to match canvas size
        const w = Math.floor(video.videoWidth * this.scale);
        const h = Math.floor(video.videoHeight * this.scale);

        this.src = new cv.Mat(h, w, cv.CV_8UC4);
        this.gray = new cv.Mat();

        // ArUco detection setup
        if (this.useAruco) {
            try {
                // Use DICT_4X4_50 dictionary (small, fast, good for mobile)
                this.dictionary = new cv.aruco_Dictionary(cv.DICT_4X4_50);
                this.detectorParams = new cv.aruco_DetectorParameters();

                // Improve detection parameters for better reliability
                this.detectorParams.adaptiveThreshConstant = 7;
                this.detectorParams.adaptiveThreshWinSizeMin = 3;
                this.detectorParams.adaptiveThreshWinSizeMax = 23;
                this.detectorParams.adaptiveThreshWinSizeStep = 10;
                this.detectorParams.minMarkerPerimeterRate = 0.03;
                this.detectorParams.maxMarkerPerimeterRate = 4.0;
                this.detectorParams.polygonalApproxAccuracyRate = 0.05;
                this.detectorParams.minCornerDistanceRate = 0.05;
                this.detectorParams.minDistanceToBorder = 3;
                this.detectorParams.cornerRefinementMethod = cv.CORNER_REFINE_SUBPIX;

                console.log("ArUco detector initialized with enhanced parameters");
            } catch(e) {
                console.warn("ArUco not available, falling back to square detection:", e);
                this.useAruco = false;
            }
        }

        // Fallback to square detection
        if (!this.useAruco) {
            this.blurred = new cv.Mat();
            this.binary = new cv.Mat();
            this.contours = new cv.MatVector();
            this.hierarchy = new cv.Mat();
        }

        this.ready = true;
    }

    findMarker(video, markerSize, detectionMode = 'single') {
        if(!this.ready) return null;
        const w = Math.floor(video.videoWidth * this.scale);
        const h = Math.floor(video.videoHeight * this.scale);

        if(!this._ctx) {
            const c = document.createElement('canvas');
            c.width = w; c.height = h;
            this._ctx = c.getContext('2d', {willReadFrequently:true});
        }

        // Ensure Mat dimensions match canvas dimensions
        if(this.src.cols !== w || this.src.rows !== h) {
            this.src.delete();
            this.src = new cv.Mat(h, w, cv.CV_8UC4);
        }

        this._ctx.drawImage(video, 0, 0, w, h);
        this.src.data.set(this._ctx.getImageData(0,0,w,h).data);
        cv.cvtColor(this.src, this.gray, cv.COLOR_RGBA2GRAY);

        // Apply histogram equalization for better contrast in challenging lighting
        // This helps detect markers in poor lighting or high contrast situations
        cv.equalizeHist(this.gray, this.gray);

        if (this.useAruco) {
            if (detectionMode === 'single') {
                return this._findArucoMarker(video, markerSize);
            } else {
                return this._findMultipleArucoMarkers(video, markerSize, detectionMode);
            }
        } else {
            return this._findSquareMarker(video, markerSize, w, h);
        }
    }

    _findArucoMarker(video, markerSize) {
        try {
            const markerCorners = new cv.MatVector();
            const markerIds = new cv.Mat();
            const rejectedCandidates = new cv.MatVector();

            // Detect ArUco markers
            cv.detectMarkers(this.gray, this.dictionary, markerCorners, markerIds, this.detectorParams, rejectedCandidates);

            if (markerIds.rows > 0) {
                // Use the first detected marker
                const corners = markerCorners.get(0);
                const pose = this._getPoseFromCorners(corners, video.videoWidth, video.videoHeight, this.scale, markerSize);

                // Store rotation for parallax effects
                pose.rotation = this._getRotationFromCorners(corners);

                markerCorners.delete();
                markerIds.delete();
                rejectedCandidates.delete();

                return pose;
            }

            markerCorners.delete();
            markerIds.delete();
            rejectedCandidates.delete();
        } catch(e) {
            console.error("ArUco detection error:", e);
        }
        return null;
    }

    _findMultipleArucoMarkers(video, markerSize, detectionMode) {
        try {
            const markerCorners = new cv.MatVector();
            const markerIds = new cv.Mat();
            const rejectedCandidates = new cv.MatVector();

            // Detect ArUco markers
            cv.detectMarkers(this.gray, this.dictionary, markerCorners, markerIds, this.detectorParams, rejectedCandidates);

            const detectedMarkers = {};
            const detectedIds = [];

            // Required number of markers based on detection mode
            const requiredCount = detectionMode === '4-marker' ? 4 : 5;

            // Parse ALL detected markers (accept any IDs)
            if (markerIds.rows > 0) {
                for (let i = 0; i < markerIds.rows; i++) {
                    const id = markerIds.data32S[i];
                    const corners = markerCorners.get(i);
                    detectedMarkers[id] = {
                        id: id,
                        corners: corners,
                        center: this._getMarkerCenter(corners, this.scale)
                    };
                    detectedIds.push(id);
                }
                console.log(`Detected ${detectedIds.length} markers: IDs [${detectedIds.join(', ')}]`);
            } else {
                // Log when no markers are detected to help debugging
                if (Math.random() < 0.1) { // Only log 10% of the time to avoid spam
                    console.log(`No ArUco markers detected. Rejected candidates: ${rejectedCandidates.size()}`);
                }
            }

            // Calculate pose based on detected markers
            let pose = null;
            if (detectedIds.length >= 2) {
                // Need at least 2 markers for multi-marker mode
                pose = this._calculateMultiMarkerPose(detectedMarkers, detectedIds, video, markerSize, detectionMode);
            }

            // Always return detection info, even if we can't calculate pose yet
            // This allows UI to show partial detection feedback
            if (detectedIds.length > 0) {
                if (!pose) {
                    // Not enough markers for pose, but we detected some - return partial info
                    pose = {
                        x: 0, y: 0, z: -1000, // Default position
                        rotation: null,
                        partialDetection: true
                    };
                }
                pose.detectedIds = detectedIds;
                pose.detectedMarkers = detectedMarkers;
                pose.requiredCount = requiredCount;
                pose.allMarkersFound = detectedIds.length >= requiredCount;
            }

            markerCorners.delete();
            markerIds.delete();
            rejectedCandidates.delete();

            return pose;
        } catch(e) {
            console.error("Multi-marker ArUco detection error:", e);
        }
        return null;
    }

    _getMarkerCenter(corners, scale) {
        const c = [];
        for(let i = 0; i < 4; i++) {
            c.push({
                x: corners.data32F[i * 2] / scale,
                y: corners.data32F[i * 2 + 1] / scale
            });
        }
        const cx = (c[0].x + c[1].x + c[2].x + c[3].x) / 4;
        const cy = (c[0].y + c[1].y + c[2].y + c[3].y) / 4;
        return { x: cx, y: cy };
    }

    _calculateMultiMarkerPose(markers, detectedIds, video, markerSize, mode) {
        // Multi-marker pose calculation
        // markerSize = physical size of each marker's BLACK SQUARE AREA (in mm)
        // All markers should be measured consistently (black area only, no white border)

        const vw = video.videoWidth;
        const vh = video.videoHeight;

        // Sort markers by position to identify corners (TL, TR, BL, BR)
        const sortedMarkers = this._sortMarkersByPosition(markers, detectedIds);

        // Calculate average scale from all detected markers
        // Each marker's black square is measured and averaged for better accuracy
        let totalScale = 0;
        let scaleCount = 0;

        for (let id of detectedIds) {
            const corners = markers[id].corners;
            const c = [];
            for(let i = 0; i < 4; i++) {
                c.push({
                    x: corners.data32F[i * 2] / this.scale,
                    y: corners.data32F[i * 2 + 1] / this.scale
                });
            }

            // Measure this marker's black square in pixels (average of 4 edges)
            const wPx = (
                Math.hypot(c[0].x-c[1].x, c[0].y-c[1].y) +
                Math.hypot(c[1].x-c[2].x, c[1].y-c[2].y) +
                Math.hypot(c[2].x-c[3].x, c[2].y-c[3].y) +
                Math.hypot(c[3].x-c[0].x, c[3].y-c[0].y)
            ) / 4;

            totalScale += wPx / markerSize;
            scaleCount++;
        }

        const avgScale = totalScale / scaleCount;

        // Use spatial layout to determine center position
        // For 4 markers: use rectangle center
        // For 5 markers: use first 4 as rectangle, 5th as outlier
        let centroidX, centroidY;

        if (detectedIds.length >= 4) {
            // Use the 4 most spatially distributed markers (corners of rectangle)
            const cornerMarkers = sortedMarkers.slice(0, 4);
            centroidX = cornerMarkers.reduce((sum, m) => sum + m.center.x, 0) / 4;
            centroidY = cornerMarkers.reduce((sum, m) => sum + m.center.y, 0) / 4;
        } else {
            // Less than 4 markers: use simple average
            centroidX = detectedIds.reduce((sum, id) => sum + markers[id].center.x, 0) / detectedIds.length;
            centroidY = detectedIds.reduce((sum, id) => sum + markers[id].center.y, 0) / detectedIds.length;
        }

        // Calculate depth using pinhole camera model
        const vFovRad = 60 * Math.PI / 180;
        const focal = (vh / 2) / Math.tan(vFovRad / 2);
        const z = -(markerSize * focal) / (avgScale * markerSize);

        // Convert centroid to 3D position
        const x = (centroidX - vw/2) * (Math.abs(z)/focal);
        const y = (centroidY - vh/2) * (Math.abs(z)/focal) * -1;

        // Calculate rotation from rectangle orientation (if we have 4+ markers)
        let rotation = null;
        if (sortedMarkers.length >= 2) {
            // Use angle between top-left and top-right markers for rotation
            const dx = sortedMarkers[1].center.x - sortedMarkers[0].center.x;
            const dy = sortedMarkers[1].center.y - sortedMarkers[0].center.y;
            const rotZ = Math.atan2(dy, dx);
            rotation = { x: 0, y: 0, z: rotZ };
        } else if (detectedIds.length > 0) {
            // Fallback: use first marker
            rotation = this._getRotationFromCorners(markers[detectedIds[0]].corners);
        }

        return { x, y, z, rotation };
    }

    _sortMarkersByPosition(markers, detectedIds) {
        // Convert to array with positions
        const markerArray = detectedIds.map(id => ({
            id: id,
            center: markers[id].center,
            corners: markers[id].corners
        }));

        // Sort by Y position first (top to bottom), then by X (left to right)
        markerArray.sort((a, b) => {
            const yDiff = a.center.y - b.center.y;
            if (Math.abs(yDiff) > 50) return yDiff; // Significant Y difference
            return a.center.x - b.center.x; // Sort by X if similar Y
        });

        // Identify approximate corners: TL, TR, BL, BR
        if (markerArray.length >= 4) {
            // Take top 2 and bottom 2
            const top2 = markerArray.slice(0, 2).sort((a, b) => a.center.x - b.center.x);
            const bottom2 = markerArray.slice(-2).sort((a, b) => a.center.x - b.center.x);
            return [...top2, ...bottom2]; // [TL, TR, BL, BR]
        }

        return markerArray;
    }

    _findSquareMarker(video, markerSize, w, h) {
        // Apply Gaussian blur to reduce noise
        const ksize = new cv.Size(5, 5);
        cv.GaussianBlur(this.gray, this.blurred, ksize, 0);

        // Use Otsu's thresholding for better binary conversion
        cv.threshold(this.blurred, this.binary, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

        // Find contours
        cv.findContours(this.binary, this.contours, this.hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        let bestPose = null;
        let maxArea = 0;
        const minArea = 800;
        const maxArea_limit = (w * h) * 0.7;

        for (let i = 0; i < this.contours.size(); ++i) {
            let cnt = this.contours.get(i);
            let area = cv.contourArea(cnt);

            if (area > minArea && area < maxArea_limit) {
                let peri = cv.arcLength(cnt, true);
                let approx = new cv.Mat();
                cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

                if (approx.rows === 4 && cv.isContourConvex(approx)) {
                    // Check if it's roughly square by comparing aspect ratio
                    const rect = cv.boundingRect(approx);
                    const aspectRatio = Math.max(rect.width, rect.height) / Math.min(rect.width, rect.height);

                    // Accept markers with aspect ratio <= 1.4 (roughly square)
                    if (aspectRatio <= 1.4 && area > maxArea) {
                        maxArea = area;
                        bestPose = this._getPoseFromApprox(approx, video.videoWidth, video.videoHeight, this.scale, markerSize);
                    }
                }
                approx.delete();
            }
        }
        return bestPose;
    }

    _getRotationFromCorners(corners) {
        // Extract corner points (ArUco markers have 4 corners)
        const c = [];
        for(let i = 0; i < 4; i++) {
            c.push({
                x: corners.data32F[i * 2],
                y: corners.data32F[i * 2 + 1]
            });
        }

        // Calculate rotation angles based on marker orientation
        // Vector from corner 0 to corner 1 (top edge)
        const dx = c[1].x - c[0].x;
        const dy = c[1].y - c[0].y;
        const rotZ = Math.atan2(dy, dx);

        // Estimate tilt based on perspective distortion
        const topWidth = Math.hypot(c[1].x - c[0].x, c[1].y - c[0].y);
        const bottomWidth = Math.hypot(c[2].x - c[3].x, c[2].y - c[3].y);
        const rotX = Math.atan((topWidth - bottomWidth) / ((topWidth + bottomWidth) / 2)) * 0.5;

        const leftHeight = Math.hypot(c[3].x - c[0].x, c[3].y - c[0].y);
        const rightHeight = Math.hypot(c[2].x - c[1].x, c[2].y - c[1].y);
        const rotY = Math.atan((leftHeight - rightHeight) / ((leftHeight + rightHeight) / 2)) * 0.5;

        return { x: rotX, y: rotY, z: rotZ };
    }

    _getPoseFromCorners(corners, vw, vh, scale, markerSize) {
        // IMPORTANT: Marker measurement methodology
        // ==========================================
        // markerSize parameter = physical size of BLACK SQUARE AREA ONLY (in mm)
        // - This EXCLUDES the white border/quiet zone around the ArUco marker
        // - OpenCV's detectMarkers() returns corners at the OUTER EDGE of the black square
        // - This makes manual verification easy: users measure with a ruler on the black area
        // - For less accurately printed markers, white borders may vary, but black area is consistent
        //
        // ArUco marker structure (DICT_4X4_50):
        // - White border (quiet zone) - NOT measured
        // - Black square (6x6 modules: 1 border + 4x4 pattern + 1 border) - THIS is measured
        // - Users should measure the entire black square with a ruler

        // Extract corner points
        const c = [];
        for(let i = 0; i < 4; i++) {
            c.push({
                x: corners.data32F[i * 2] / scale,
                y: corners.data32F[i * 2 + 1] / scale
            });
        }

        // Calculate marker width in pixels (average of all four edges)
        // This measures the detected black square area in screen pixels
        const wPx = (
            Math.hypot(c[0].x-c[1].x, c[0].y-c[1].y) +
            Math.hypot(c[1].x-c[2].x, c[1].y-c[2].y) +
            Math.hypot(c[2].x-c[3].x, c[2].y-c[3].y) +
            Math.hypot(c[3].x-c[0].x, c[3].y-c[0].y)
        ) / 4;

        // Calculate pose using pinhole camera model
        const vFovRad = 60 * Math.PI / 180;
        const focal = (vh / 2) / Math.tan(vFovRad / 2);
        const z = -(markerSize * focal) / wPx;

        // Calculate center of marker (average of all corners)
        const cx = (c[0].x + c[1].x + c[2].x + c[3].x) / 4;
        const cy = (c[0].y + c[1].y + c[2].y + c[3].y) / 4;

        // Convert to 3D position
        const x = (cx - vw/2) * (Math.abs(z)/focal);
        const y = (cy - vh/2) * (Math.abs(z)/focal) * -1;

        return { x, y, z };
    }

    _getPoseFromApprox(approx, vw, vh, scale, markerSize) {
        // Fallback square detection (used when ArUco detection unavailable)
        // markerSize = physical size of detected square's BLACK AREA (in mm)

        const c = [];
        for(let j=0; j<8; j+=2) c.push({x: approx.data32S[j]/scale, y: approx.data32S[j+1]/scale});

        // Calculate marker width in pixels (average of all four edges)
        const wPx = (
            Math.hypot(c[0].x-c[1].x, c[0].y-c[1].y) +
            Math.hypot(c[1].x-c[2].x, c[1].y-c[2].y) +
            Math.hypot(c[2].x-c[3].x, c[2].y-c[3].y) +
            Math.hypot(c[3].x-c[0].x, c[3].y-c[0].y)
        ) / 4;

        // Calculate pose using pinhole camera model
        const vFovRad = 60 * Math.PI / 180;
        const focal = (vh / 2) / Math.tan(vFovRad / 2);
        const z = -(markerSize * focal) / wPx;

        // Calculate center of marker (average of all corners)
        const cx = (c[0].x + c[1].x + c[2].x + c[3].x) / 4;
        const cy = (c[0].y + c[1].y + c[2].y + c[3].y) / 4;

        // Convert to 3D position
        const x = (cx - vw/2) * (Math.abs(z)/focal);
        const y = (cy - vh/2) * (Math.abs(z)/focal) * -1;

        return { x, y, z };
    }
}

// ==========================================
// üé® GRAPHICS (3D Rendering with Translucent Clearances)
// ==========================================
// Note: preserveDrawingBuffer is required to capture WebGL canvas content
// in screenshots. Without it, the canvas is cleared after rendering and
// captureImage() would only save the video feed without AR graphics.
class GraphicsEngine {
    constructor(canvas) {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        this.renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.root = new THREE.Group();
        this.scene.add(this.root);
        this.stencil = null;
        this.parallaxEnabled = true;
    }

    setStencil(data) {
        if(this.stencil) this.root.remove(this.stencil);
        this.stencil = new THREE.Group();
        
        if(data.type === 'flue') {
            this._createRadial(data);
        } else {
            this._createBox(data);
        }
        
        this.stencil.position.x = 150; 
        this.root.add(this.stencil);
    }

    _createBox(data) {
        // Clearance calculations
        let clearanceTop, clearanceBottom, clearanceLeft, clearanceRight, clearanceFront;

        if (typeof data.clearance === 'object' && data.clearance !== null && !Array.isArray(data.clearance)) {
            clearanceTop = data.clearance.top || 0;
            clearanceBottom = data.clearance.bottom || 0;
            clearanceLeft = data.clearance.left || 0;
            clearanceRight = data.clearance.right || 0;
            clearanceFront = data.clearance.front || 0;
        } else {
            clearanceTop = clearanceBottom = clearanceLeft = clearanceRight = clearanceFront = data.clearance || 0;
        }

        const zW = data.w + clearanceLeft + clearanceRight;
        const zH = data.h + clearanceTop + clearanceBottom;
        const zD = data.d + clearanceFront;

        const offsetX = (clearanceRight - clearanceLeft) / 2;
        const offsetY = (clearanceTop - clearanceBottom) / 2;
        const offsetZ = clearanceFront / 2;

        // 1. Create 3D Appliance Box (Blue - solid representation)
        const applianceGeo = new THREE.BoxGeometry(data.w, data.h, data.d);
        const applianceMat = new THREE.MeshBasicMaterial({
            color: 0x005eb8,
            opacity: 0.3,
            transparent: true,
            side: THREE.DoubleSide
        });
        const applianceMesh = new THREE.Mesh(applianceGeo, applianceMat);
        applianceMesh.position.set(0, 0, -data.d/2);
        this.stencil.add(applianceMesh);

        // 2. Appliance Edges (Blue outline)
        const applianceEdges = new THREE.EdgesGeometry(applianceGeo);
        const applianceLines = new THREE.LineSegments(applianceEdges, new THREE.LineBasicMaterial({
            color: 0x005eb8,
            linewidth: 2
        }));
        applianceLines.position.set(0, 0, -data.d/2);
        this.stencil.add(applianceLines);

        // 3. Create 3D Clearance Zone Box (Red - translucent volume)
        const clearanceGeo = new THREE.BoxGeometry(zW, zH, zD);
        const clearanceMat = new THREE.MeshBasicMaterial({
            color: 0xe30613,
            opacity: 0.15,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false  // Allows proper transparency layering
        });
        const clearanceMesh = new THREE.Mesh(clearanceGeo, clearanceMat);
        clearanceMesh.position.set(offsetX, offsetY, -zD/2);
        this.stencil.add(clearanceMesh);

        // 4. Clearance Zone Edges (Red outline)
        const clearanceEdges = new THREE.EdgesGeometry(clearanceGeo);
        const clearanceLines = new THREE.LineSegments(clearanceEdges, new THREE.LineBasicMaterial({
            color: 0xe30613,
            linewidth: 2
        }));
        clearanceLines.position.set(offsetX, offsetY, -zD/2);
        this.stencil.add(clearanceLines);

        // 5. Add front-face hatching for better visibility
        const hatchPoints = [];
        const startX = -zW/2 + offsetX, endX = zW/2 + offsetX;
        const startY = -zH/2 + offsetY, endY = zH/2 + offsetY;

        // Diagonal hatching lines (45 degrees) on the front face
        for(let x = startX - zH; x < endX + zH; x += 40) {
            hatchPoints.push(new THREE.Vector3(x, startY, 0));
            hatchPoints.push(new THREE.Vector3(x + zH, endY, 0));
        }

        const hatchMat = new THREE.LineBasicMaterial({ color: 0xe30613, opacity: 0.4, transparent: true });
        this.stencil.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(hatchPoints), hatchMat));

        // 6. Add dimension labels (optional - for better UX)
        if (clearanceFront > 0) {
            this._addDepthIndicator(data.w, data.h, -data.d, clearanceFront);
        }
    }

    _addDepthIndicator(w, h, startZ, depth) {
        // Visual indicator showing the clearance depth (front)
        const points = [];
        points.push(new THREE.Vector3(w/2 + 50, h/2 + 50, startZ));
        points.push(new THREE.Vector3(w/2 + 50, h/2 + 50, startZ - depth));

        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
        const lineMat = new THREE.LineBasicMaterial({ color: 0xe30613, linewidth: 2 });
        const line = new THREE.Line(lineGeo, lineMat);
        this.stencil.add(line);

        // Add arrow heads
        const arrowSize = 30;
        const arrowPoints = [
            new THREE.Vector3(w/2 + 50, h/2 + 50, startZ),
            new THREE.Vector3(w/2 + 30, h/2 + 50, startZ - 20),
            new THREE.Vector3(w/2 + 70, h/2 + 50, startZ - 20),
            new THREE.Vector3(w/2 + 50, h/2 + 50, startZ)
        ];
        const arrowGeo = new THREE.BufferGeometry().setFromPoints(arrowPoints);
        const arrow = new THREE.Line(arrowGeo, lineMat);
        this.stencil.add(arrow);
    }

    _createRadial(data) {
        const ring = new THREE.Mesh(new THREE.RingGeometry(0, data.radius, 32), new THREE.MeshBasicMaterial({color:0x333333}));
        const zone = new THREE.Mesh(new THREE.RingGeometry(data.radius, data.clearance, 32), new THREE.MeshBasicMaterial({color:0xe30613, opacity:0.3, transparent:true, side:THREE.DoubleSide}));
        this.stencil.add(ring, zone);
    }

    render() { this.renderer.render(this.scene, this.camera); }
}

// ==========================================
// üì± CONTROLLER (Updated Initialization Logic)
// ==========================================
const App = {
    markerSize: 190,
    detectionMode: 'single',
    multiMarkerSize: 90,
    vision: new VisionSystem(),
    graphics: null,
    locked: false,
    cvReady: false,
    loadTimeoutId: null, // Timer to track long initialization
    
    // Contextual hint timing (milliseconds)
    HINT_DELAY_INITIAL: 3000,  // "Try moving closer"
    HINT_DELAY_LIGHTING: 8000, // "Check lighting"
    HINT_DELAY_GUIDE: 15000,   // "See marker guide"

    onCvLoaded: function() {
        console.log("OpenCV script file loaded successfully. Starting internal initialization check.");
        
        // Start a timeout. If initialization is not complete after 10 seconds, assume failure.
        this.loadTimeoutId = setTimeout(() => {
            if (!this.cvReady) {
                this.cvReady = null; // Mark as failed to stop the polling loop
                this.handleInitializationFailure("OpenCV failed to initialize after 10 seconds.");
            }
        }, 10000); 

        const checkCvReady = () => {
            // Check 1: Global cv object exists, Check 2: Basic OpenCV functionality is available
            if (typeof cv !== 'undefined' && cv.Mat) {
                clearTimeout(this.loadTimeoutId); // Clear the failure timer
                this.cvReady = true;
                this.updateModels();

                // Enable button and update text
                const startBtn = document.getElementById('start-camera-btn');
                
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Camera';
                }

                console.log("OpenCV Ready");
            } else {
                // Keep trying every 100ms, only if timeout hasn't occurred
                if (this.cvReady === false) {
                    setTimeout(checkCvReady, 100);
                }
            }
        };
        checkCvReady();
    },
    
    // Handles failures if the script was downloaded but initialization stalled
    handleInitializationFailure: function(message) {
        console.error(message);
        
        // Update button state to show error
        const startBtn = document.getElementById('start-camera-btn');
        if (startBtn) {
            startBtn.textContent = 'Initialization Failed';
            startBtn.style.background = '#e30613';
            startBtn.disabled = true;
        }

        alert(message + "\n\nPossible causes:\n- OpenCV.js file could not be loaded\n- Browser security restrictions\n- Not running through a local web server\n- File path is incorrect\n\nCheck browser console (F12) for details.");
    },

    // Core function to handle failed OpenCV script download (network error)
    onCvError: function() {
        this.handleInitializationFailure("OpenCV script failed to download (Network Error).");
    },

    // Show main menu from welcome screen
    showMainMenu: function() {
        document.getElementById('welcome-panel').classList.add('hidden');
        document.getElementById('menu-panel').classList.remove('hidden');
    },

    // Handle marker size selection change
    onSizeChange: function() {
        const sizeSelect = document.getElementById('input-size');
        const customContainer = document.getElementById('custom-size-container');

        if (sizeSelect.value === 'custom') {
            customContainer.classList.remove('hidden');
        } else {
            customContainer.classList.add('hidden');
        }
    },

    // Handle detection mode selection change
    onDetectionModeChange: function() {
        const modeSelect = document.getElementById('input-detection-mode');
        const singleMarkerContainer = document.getElementById('single-marker-size-container');
        const multiMarkerContainer = document.getElementById('multi-marker-size-container');

        this.detectionMode = modeSelect.value;

        if (this.detectionMode === 'single') {
            // Show single marker size selector, hide multi-marker size
            singleMarkerContainer.classList.remove('hidden');
            multiMarkerContainer.classList.add('hidden');
        } else {
            // Show multi-marker size input, hide single marker size
            singleMarkerContainer.classList.add('hidden');
            multiMarkerContainer.classList.remove('hidden');
        }
    },

    // Handle model selection change
    onModelChange: function() {
        const modelSelect = document.getElementById('input-type');
        const customRadiatorContainer = document.getElementById('custom-radiator-container');
        const index = parseInt(modelSelect.value, 10);
        
        // Check if the selected model is the custom radiator
        if (!isNaN(index) && index >= 0 && index < APPLIANCE_DB.length) {
            const selectedItem = APPLIANCE_DB[index];
            if (selectedItem.id === 'rad_custom') {
                customRadiatorContainer.classList.remove('hidden');
            } else {
                customRadiatorContainer.classList.add('hidden');
            }
        } else {
            customRadiatorContainer.classList.add('hidden');
        }
    },

    // Filters the list based on category
    updateModels: function() {
        const category = document.getElementById('input-category').value;
        const modelSelect = document.getElementById('input-type');
        
        // Clear existing options
        modelSelect.innerHTML = "";

        // Filter DB and create new options
        APPLIANCE_DB.forEach((item, index) => {
            if (item.category === category) {
                const opt = document.createElement('option');
                // We store the array INDEX as the value so we can look it up easily later
                opt.value = index; 
                opt.text = item.label;
                modelSelect.appendChild(opt);
            }
        });
        
        // Trigger model change to update custom input visibility
        this.onModelChange();
    },

    startSession: async function() {
        if (!this.cvReady) {
            alert("OpenCV is still loading. Please wait a moment.");
            return;
        }

        // Get manual depth offset
        const depthOffset = parseInt(document.getElementById('manual-depth-offset').value, 10);
        this.manualDepthOffset = isNaN(depthOffset) ? 0 : depthOffset;

        // Get detection mode
        this.detectionMode = document.getElementById('input-detection-mode').value;

        // Get marker size based on detection mode
        if (this.detectionMode === 'single') {
            const sizeSelect = document.getElementById('input-size').value;

            // Get marker size from either preset or custom input
            if (sizeSelect === 'custom') {
                const customSize = parseInt(document.getElementById('custom-size-input').value, 10);
                if (isNaN(customSize) || customSize < 10 || customSize > 500) {
                    alert('Please enter a valid marker size between 10 and 500 millimeters.\n\nRemember: Measure the BLACK SQUARE AREA ONLY, excluding the white border.');
                    return;
                }
                this.markerSize = customSize;
            } else {
                this.markerSize = parseInt(sizeSelect, 10);
            }
        } else {
            // Multi-marker mode: use multi-marker size input
            const multiSize = parseInt(document.getElementById('multi-marker-size-input').value, 10);
            if (isNaN(multiSize) || multiSize < 10 || multiSize > 500) {
                alert('Please enter a valid multi-marker size between 10 and 500 millimeters.\n\nRemember: Measure the BLACK SQUARE AREA ONLY, excluding the white border.');
                return;
            }
            this.multiMarkerSize = multiSize;
            this.markerSize = multiSize; // Use multi-marker size for calculations
        }
        
        const index = parseInt(document.getElementById('input-type').value, 10);
        
        // Validate index
        if(isNaN(index) || index < 0 || index >= APPLIANCE_DB.length) {
            console.error('Invalid appliance selection');
            return;
        }
        
        let data = APPLIANCE_DB[index];
        
        // Handle custom radiator dimensions
        if (data.id === 'rad_custom') {
            const customWidth = parseInt(document.getElementById('custom-radiator-width').value, 10);
            const customHeight = parseInt(document.getElementById('custom-radiator-height').value, 10);
            
            if (isNaN(customWidth) || customWidth < 100 || customWidth > 3000) {
                alert('Please enter a valid radiator width between 100 and 3000 mm');
                return;
            }
            
            if (isNaN(customHeight) || customHeight < 100 || customHeight > 2000) {
                alert('Please enter a valid radiator height between 100 and 2000 mm');
                return;
            }
            
            // Create a copy of the data with custom dimensions
            data = { ...data, w: customWidth, h: customHeight };
        }

        document.getElementById('menu-panel').classList.add('hidden');
        document.getElementById('controls-panel').classList.remove('hidden');
        document.getElementById('status-pill').classList.remove('hidden');
        document.getElementById('status-pill').textContent = "üîç Point at Marker...";

        const video = document.getElementById('camera-layer');
        video.srcObject = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'environment', width: { ideal: 1280 } } 
        });

        this.graphics = new GraphicsEngine(document.getElementById('ar-layer'));
        this.graphics.setStencil(data);
        this.setupTouch();
        this.vision.init(video);
        this.loop();
    },

    loop: function() {
        requestAnimationFrame(this.loop.bind(this));
        const video = document.getElementById('camera-layer');
        if(video.readyState !== 4) return;

        this.graphics.render();

        if(!this.locked) {
            const pose = this.vision.findMarker(video, this.markerSize, this.detectionMode);
            if(pose) {
                // Update position with smooth interpolation (only if not partial detection)
                if (!pose.partialDetection) {
                    // Apply manual depth offset to z position
                    const targetZ = pose.z - this.manualDepthOffset;

                    const t = this.graphics.root.position;
                    t.x += (pose.x - t.x) * 0.2;
                    t.y += (pose.y - t.y) * 0.2;
                    t.z += (targetZ - t.z) * 0.2;

                    // Apply parallax rotation if available (from ArUco detection)
                    if(pose.rotation && this.graphics.parallaxEnabled) {
                        const r = this.graphics.root.rotation;
                        r.x += (pose.rotation.x - r.x) * 0.15;
                        r.y += (pose.rotation.y - r.y) * 0.15;
                        r.z += (pose.rotation.z - r.z) * 0.15;
                    }
                }

                // Update status based on detection mode
                if (this.detectionMode === 'single') {
                    document.getElementById('status-pill').textContent = "‚úì Tracking";
                    document.getElementById('status-pill').className = "locked";
                } else {
                    // Multi-marker mode: show detected markers count with visual indicators
                    const count = pose.detectedIds.length;
                    const required = pose.requiredCount;
                    
                    // Create visual progress indicators (dots): filled (‚óè) for detected, empty (‚óã) for missing
                    const dots = Array(required).fill(null).map((_, i) => i < count ? '‚óè' : '‚óã').join('');
                    
                    const statusText = pose.allMarkersFound
                        ? `‚úì Ready ${dots}`
                        : `${dots} ${count}/${required}`;
                    document.getElementById('status-pill').textContent = statusText;
                    document.getElementById('status-pill').className = pose.allMarkersFound ? "locked" : "";

                    // Draw marker feedback on canvas (always show detected markers)
                    this.drawMarkerFeedback(pose);
                }
            } else {
                // No marker detected - show helpful tips after a few seconds
                if (!this._noDetectionTime) {
                    this._noDetectionTime = Date.now();
                }
                
                const noDetectionDuration = Date.now() - this._noDetectionTime;
                
                if (noDetectionDuration < this.HINT_DELAY_INITIAL) {
                    document.getElementById('status-pill').textContent = "üîç Looking...";
                } else if (noDetectionDuration < this.HINT_DELAY_LIGHTING) {
                    document.getElementById('status-pill').textContent = "üí° Try moving closer";
                } else if (noDetectionDuration < this.HINT_DELAY_GUIDE) {
                    document.getElementById('status-pill').textContent = "üí° Check lighting";
                } else {
                    document.getElementById('status-pill').textContent = "üí° See marker guide";
                }
                document.getElementById('status-pill').className = "";

                // Clear marker feedback
                if (this.detectionMode !== 'single') {
                    this.clearMarkerFeedback();
                }
            }
            
            // Reset no detection timer when marker is found
            if (pose) {
                this._noDetectionTime = null;
            }
        }
    },

    drawMarkerFeedback: function(pose) {
        const canvas = document.getElementById('marker-feedback-layer');
        const video = document.getElementById('camera-layer');

        if (!canvas || !pose.detectedMarkers) return;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calculate scaling factors to match video display
        const videoAspect = video.videoWidth / video.videoHeight;
        const canvasAspect = canvas.width / canvas.height;

        let scaleX, scaleY, offsetX, offsetY;

        if (videoAspect > canvasAspect) {
            // Video is wider - covers height, cropped horizontally
            scaleY = canvas.height / video.videoHeight;
            scaleX = scaleY;
            offsetX = (canvas.width - (video.videoWidth * scaleX)) / 2;
            offsetY = 0;
        } else {
            // Video is taller - covers width, cropped vertically
            scaleX = canvas.width / video.videoWidth;
            scaleY = scaleX;
            offsetX = 0;
            offsetY = (canvas.height - (video.videoHeight * scaleY)) / 2;
        }

        // Draw detected markers with enhanced visual feedback
        for (let id in pose.detectedMarkers) {
            const marker = pose.detectedMarkers[id];
            const center = marker.center;

            // Transform coordinates
            const x = center.x * scaleX + offsetX;
            const y = center.y * scaleY + offsetY;

            // Draw outer glow effect
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 15;
            
            // Draw marker corners with gradient
            const corners = marker.corners;
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const cx = corners.data32F[i * 2] / this.vision.scale * scaleX + offsetX;
                const cy = corners.data32F[i * 2 + 1] / this.vision.scale * scaleY + offsetY;
                if (i === 0) {
                    ctx.moveTo(cx, cy);
                } else {
                    ctx.lineTo(cx, cy);
                }
            }
            ctx.closePath();
            ctx.stroke();
            
            // Reset shadow for center indicator
            ctx.shadowBlur = 0;

            // Draw marker center with checkmark
            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
            ctx.beginPath();
            ctx.arc(x, y, 35, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Draw checkmark or marker ID
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚úì', x, y);
            
            // Draw marker ID label below
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - 20, y + 45, 40, 24);
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`ID: ${id}`, x, y + 57);
        }
    },

    clearMarkerFeedback: function() {
        const canvas = document.getElementById('marker-feedback-layer');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    },

    setupTouch: function() {
        const pad = document.getElementById('touch-pad');
        let drag=false, sx=0, sy=0, ox=0, oy=0;
        pad.addEventListener('touchstart', e => {
            if(this.locked) return;
            drag=true; sx=e.touches[0].clientX; sy=e.touches[0].clientY;
            ox=this.graphics.stencil.position.x; oy=this.graphics.stencil.position.y;
        });
        pad.addEventListener('touchmove', e => {
            if(!drag) return;
            const scale = Math.abs(this.graphics.root.position.z)/1000 * 2.5;
            this.graphics.stencil.position.x = ox + (e.touches[0].clientX-sx)*scale;
            this.graphics.stencil.position.y = oy - (e.touches[0].clientY-sy)*scale;
        });
        pad.addEventListener('touchend', () => drag=false);
    },

    lockView: function() {
        this.locked = true;
        document.getElementById('camera-layer').pause();
        document.getElementById('controls-panel').classList.add('hidden');
        document.getElementById('result-panel').classList.remove('hidden');
    },

    unlockView: function() {
        this.locked = false;
        document.getElementById('camera-layer').play();
        document.getElementById('controls-panel').classList.remove('hidden');
        document.getElementById('result-panel').classList.add('hidden');
        document.getElementById('status-pill').textContent = "üîç Point at Marker...";
        document.getElementById('status-pill').className = "";
        this.clearMarkerFeedback();
    },

    resetObject: function() { this.graphics.stencil.position.set(150,0,0); },

    startAgain: function() {
        // Stop camera stream
        const video = document.getElementById('camera-layer');
        if (video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
            video.srcObject = null;
        }

        // Reset state
        this.locked = false;
        this.graphics = null;

        // Hide result panel and status pill
        document.getElementById('result-panel').classList.add('hidden');
        document.getElementById('status-pill').classList.add('hidden');

        // Show menu panel
        document.getElementById('menu-panel').classList.remove('hidden');
    },
    
    // Captures combined image: video feed + AR graphics overlay
    // Correctly handles video with 'object-fit: cover' behavior
    // Uses Web Share API to save directly to gallery/photos on supported devices
    captureImage: async function() {
        const canvas = document.createElement('canvas');
        const video = document.getElementById('camera-layer');
        const arCanvas = document.getElementById('ar-layer');

        // Use window dimensions to match the AR canvas size (which is full screen)
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');

        // --- Calculate video draw parameters to replicate object-fit: cover ---
        const videoAspect = video.videoWidth / video.videoHeight;
        const canvasAspect = canvas.width / canvas.height;

        let drawWidth, drawHeight, offsetX, offsetY;

        if (videoAspect > canvasAspect) {
            // Video is wider than canvas ratio (covers height, cropped horizontally)
            drawHeight = canvas.height;
            drawWidth = drawHeight * videoAspect;
            offsetX = (canvas.width - drawWidth) / 2;
            offsetY = 0;
        } else {
            // Video is taller than canvas ratio (covers width, cropped vertically)
            drawWidth = canvas.width;
            drawHeight = drawWidth / videoAspect;
            offsetX = 0;
            offsetY = (canvas.height - drawHeight) / 2;
        }

        // Draw the video frame with the correct scale and offset
        ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);

        // Draw the AR overlay on top
        ctx.drawImage(arCanvas, 0, 0);

        // Convert to blob
        canvas.toBlob(async function(blob) {
            const timestamp = new Date().toISOString().split('.')[0].replace(/[:.]/g, '-');
            const filename = 'clearance-check-' + timestamp + '.png';
            
            // Create a File object from the blob for Web Share API
            // Fallback to blob if File constructor not supported (older Safari)
            let file;
            try {
                file = new File([blob], filename, { type: 'image/png' });
            } catch (e) {
                // File constructor not supported, use blob directly
                file = blob;
                file.name = filename;
            }

            // Try Web Share API first (allows saving to gallery on mobile)
            if (navigator.share) {
                // Check if file sharing is supported
                // Use canShare if available, otherwise attempt to share and handle errors
                let canAttemptShare = true;
                
                if (navigator.canShare) {
                    try {
                        canAttemptShare = navigator.canShare({ files: [file] });
                    } catch (e) {
                        console.log('canShare check failed:', e);
                        canAttemptShare = false;
                    }
                }
                
                if (canAttemptShare) {
                    try {
                        await navigator.share({
                            files: [file],
                            title: 'Clearance Check',
                            text: 'AR Clearance visualization captured'
                        });
                        console.log('‚úì Image shared successfully');
                        return;
                    } catch (error) {
                        // User cancelled, file sharing not supported, or other error
                        // Fall back to download for all errors except user cancellation
                        if (error.name === 'AbortError') {
                            console.log('User cancelled share');
                            return; // Don't download if user explicitly cancelled
                        } else {
                            console.log('Share failed, falling back to download:', error);
                        }
                    }
                }
            }

            // Fallback: Traditional download method
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('‚úì Image downloaded successfully');
        }, 'image/png');
    },

    // ====================
    // APRILTAG GENERATOR
    // ====================
    showMarkerGenerator: function() {
        document.getElementById('welcome-panel').classList.add('hidden');
        document.getElementById('marker-generator-panel').classList.remove('hidden');
        
        // Handle custom size toggle
        const sizeSelect = document.getElementById('tag-size-select');
        const customContainer = document.getElementById('tag-custom-size-container');
        sizeSelect.addEventListener('change', () => {
            if (sizeSelect.value === 'custom') {
                customContainer.classList.remove('hidden');
            } else {
                customContainer.classList.add('hidden');
            }
        });
    },

    hideMarkerGenerator: function() {
        document.getElementById('marker-generator-panel').classList.add('hidden');
        document.getElementById('welcome-panel').classList.remove('hidden');
        document.getElementById('marker-preview').classList.add('hidden');
    },

    generateAprilTag: async function() {
        const familySelect = document.getElementById('tag-family-select');
        const tagIdInput = document.getElementById('tag-id-input');
        const sizeSelect = document.getElementById('tag-size-select');
        const customSizeInput = document.getElementById('tag-custom-size-input');

        const family = familySelect.value;
        const tagId = parseInt(tagIdInput.value);
        const sizeValue = sizeSelect.value === 'custom' ? 
            parseInt(customSizeInput.value) : parseInt(sizeSelect.value);

        if (isNaN(tagId) || tagId < 0) {
            alert('Please enter a valid Tag ID (0 or greater)');
            return;
        }

        if (isNaN(sizeValue) || sizeValue < 10 || sizeValue > 500) {
            alert('Please enter a valid marker size (10-500mm)');
            return;
        }

        try {
            // Load the tag family JSON
            const response = await fetch(`./apriltag-families/${family}.json`);
            const tagConfig = await response.json();

            // Create AprilTag family
            if (typeof AprilTagFamily === 'undefined') {
                // AprilTag library not loaded, try to load it from global scope
                if (typeof window.AprilTagFamily !== 'undefined') {
                    window.AprilTagFamily = window.AprilTagFamily;
                } else {
                    alert('AprilTag library not loaded. Please refresh the page.');
                    return;
                }
            }

            const tagFamily = new AprilTagFamily(tagConfig);
            
            // Check if tag ID is valid for this family
            if (tagId >= tagConfig.codes.length) {
                alert(`Tag ID ${tagId} is out of range for family ${family}. Maximum ID: ${tagConfig.codes.length - 1}`);
                return;
            }

            // Render the tag
            const tagMatrix = tagFamily.render(tagId);

            // Draw to canvas
            const canvas = document.getElementById('marker-canvas');
            const ctx = canvas.getContext('2d');

            // Calculate canvas size (tag size + border)
            const tagSize = tagMatrix.length;
            const borderSize = 1; // 1 cell border on each side
            const totalSize = tagSize + (borderSize * 2);
            const cellSize = 20; // pixels per cell

            canvas.width = totalSize * cellSize;
            canvas.height = totalSize * cellSize;

            // Fill background (white)
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw tag (apriltag.js returns 'b' for black, 'w' for white)
            ctx.fillStyle = 'black';
            for (let y = 0; y < tagSize; y++) {
                for (let x = 0; x < tagSize; x++) {
                    if (tagMatrix[y][x] === 'b') {
                        ctx.fillRect(
                            (x + borderSize) * cellSize,
                            (y + borderSize) * cellSize,
                            cellSize,
                            cellSize
                        );
                    }
                }
            }

            // Show preview and download buttons
            document.getElementById('marker-preview').classList.remove('hidden');
            
            // Store current settings for download
            this.currentMarker = {
                family: family,
                tagId: tagId,
                size: sizeValue
            };

            console.log(`‚úì Generated AprilTag: family=${family}, id=${tagId}, size=${sizeValue}mm`);
        } catch (error) {
            console.error('Error generating AprilTag:', error);
            alert('Failed to generate AprilTag. Please check the console for details.');
        }
    },

    downloadMarker: function() {
        if (!this.currentMarker) {
            alert('Please generate a marker first');
            return;
        }

        const canvas = document.getElementById('marker-canvas');
        canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `apriltag-${this.currentMarker.family}-id${this.currentMarker.tagId}-${this.currentMarker.size}mm.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log('‚úì AprilTag marker downloaded');
        }, 'image/png');
    },

    printMarker: function() {
        if (!this.currentMarker) {
            alert('Please generate a marker first');
            return;
        }

        // Create a new window for printing
        const canvas = document.getElementById('marker-canvas');
        const printWindow = window.open('', '_blank');
        const img = new Image();
        
        img.onload = function() {
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Print AprilTag Marker</title>
                    <style>
                        @page { margin: 20mm; }
                        body { margin: 0; padding: 20px; text-align: center; }
                        img { max-width: 100%; height: auto; }
                        .info { margin: 20px 0; font-family: Arial, sans-serif; }
                    </style>
                </head>
                <body>
                    <div class="info">
                        <h2>AprilTag Marker</h2>
                        <p><strong>Family:</strong> ${this.currentMarker.family}</p>
                        <p><strong>Tag ID:</strong> ${this.currentMarker.tagId}</p>
                        <p><strong>Size:</strong> ${this.currentMarker.size}mm (measure BLACK SQUARE only)</p>
                    </div>
                    <img src="${img.src}" alt="AprilTag Marker">
                    <script>window.onload = function() { window.print(); }</script>
                </body>
                </html>
            `);
            printWindow.document.close();
        }.bind(this);
        
        img.src = canvas.toDataURL('image/png');
    }
};

// ==========================================
// üì± PWA SERVICE WORKER REGISTRATION
// ==========================================
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js?v=2.1.0')
            .then((registration) => {
                console.log('‚úì Service Worker registered successfully:', registration.scope);

                // Force update check on page load
                registration.update();

                // Listen for updates and reload when a new service worker is activated
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    console.log('New Service Worker version found, installing...');

                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'activated') {
                            console.log('New Service Worker activated, reloading page...');
                            // Reload the page to get the latest version
                            window.location.reload();
                        }
                    });
                });
            })
            .catch((error) => {
                console.log('‚ùå Service Worker registration failed:', error);
            });

        // Listen for controller change (when new service worker takes over)
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            console.log('Service Worker controller changed, reloading...');
            window.location.reload();
        });
    });
}
</script>
</body>
</html>
